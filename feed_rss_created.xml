<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"> <channel><title>Cloaks | Return</title><description>欢迎来到我的博客！这里是我分享个人见解、技术文章、生活点滴和创意的地方。在这里，你将看到关于编程、技术创新、前沿趋势、以及我对生活和工作的思考与感悟。我希望我的文章能够启发你，让你收获新的知识和灵感。如果你对某些话题感兴趣，欢迎留下评论与我讨论，也可以订阅我的博客，第一时间获取最新更新。感谢你的访问，希望你在这里找到你感兴趣的内容！</description><link>https://www.cloaks.cn/</link><atom:link href="https://www.cloaks.cn/feed_rss_created.xml" rel="self" type="application/rss+xml" /><managingEditor>Cloaks</managingEditor><docs>https://github.com/cloakscn/cloakscn.github.io</docs><language>zh</language> <pubDate>Sat, 30 Aug 2025 15:07:32 -0000</pubDate> <lastBuildDate>Sat, 30 Aug 2025 15:07:32 -0000</lastBuildDate> <ttl>1440</ttl> <generator>MkDocs RSS plugin - v1.17.1</generator> <image> <url>None</url> <title>Cloaks | Return</title><link>https://www.cloaks.cn/</link> </image> <item> <title>堆排序</title> <author>Cloaks</author> <category>Golang 编程实践</category> <description>&lt;h1&gt;堆排序&lt;/h1&gt;&lt;p&gt;堆是具有以下性质的完全二叉树：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;每个节点的值都大于或等于其左右孩子节点的值，称为大顶堆；&lt;/li&gt;&lt;li&gt;或者每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;```小顶堆 10 / \ 20 15 / \ / \25 50 30 40 &lt;/p&gt;&lt;p&gt;大顶堆 50 / \ 45 40 / \ / \20 25 35 30```&lt;/p&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/08/18/</link> <pubDate>Mon, 18 Aug 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/08/18/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/08/18/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/08/18.png" type="image/png" length="61846" /> </item> <item> <title>解决：bufio.Scanner: token too long 错误</title> <author>Cloaks</author> <category>Golang 编程实践</category> <description>&lt;h1&gt;解决：bufio.Scanner: token too long 错误&lt;/h1&gt;&lt;p&gt;我在使用 &lt;code&gt;bufio.NewScanner()&lt;/code&gt; 读取文件时遇到了 “token too long” 错误。错误原因是 &lt;code&gt;bufio.Scanner&lt;/code&gt; 默认限制，最大的 &lt;code&gt;token&lt;/code&gt; 大小是 &lt;code&gt;64KB&lt;/code&gt; 当我们单行数据超过这个限制时，会报 &lt;code&gt;token too long&lt;/code&gt; 错误。&lt;/p&gt;&lt;p&gt;这其实是一个非常典型的场景，在读取非常大的数据时（比如超过几十 MB）应该采用什么方法，因为一次读取非常大的数据可能效率不高。我们首先要考虑的数据是否可以分片处理，尽可能减少对于大内存的占用。如果必须要分配大内存，也应该合理的设置缓冲区大小。&lt;/p&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/07/24/</link> <pubDate>Thu, 24 Jul 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/07/24/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/07/24/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/07/24.png" type="image/png" length="88200" /> </item> <item> <title>君子不器</title> <author>Cloaks</author> <category>札记</category> <description>&lt;h1&gt;君子不器&lt;/h1&gt;&lt;p&gt;“君子不器”出自《论语·为政》，是孔子的一句名言。其字面意思是：君子不应该像器具那样局限于单一的用途或功能。这句话表达了孔子对君子品质的期望，即君子应该具备广泛的知识和才能，而不是局限于某一特定的技能或角色。&lt;/p&gt;&lt;p&gt;在人生中我们有很多命题需要去做，比如：学习、工作、生活、家庭、朋友、爱情、事业等等。这...&lt;/p&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/06/03/</link> <pubDate>Tue, 03 Jun 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/06/03/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/06/03/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/06/03.png" type="image/png" length="62172" /> </item> <item> <title>区块 DAG（Directed Acyclic Graph，有向无环图）</title> <author>Cloaks</author> <category>区块链</category> <description>&lt;h1&gt;区块 DAG（Directed Acyclic Graph，有向无环图）&lt;/h1&gt;&lt;p&gt;​区块 DAG（Directed Acyclic Graph，有向无环图）​​ 是一种数据结构，用于描述区块链或分布式账本中交易或区块之间的关联关系。与传统区块链的线性链式结构不同，DAG 通过​​网状拓扑​​组织交易，允许多个交易并行处理，从而提升系统的扩展性和吞吐量。&lt;/p&gt;&lt;p&gt;最早在区块链中引入 DAG 概念作为共识算法是在 2013 年，bitcointalik.org 由 ID 为 avivz78 的以色列希伯来大学学者提出，也就是 GHOST 协议，作为比特币的交易处理能力扩容解决方案；Vitalik 在以太坊紫皮书描述的 POS共识协议 Casper，也是基于 GHOST POW 协议的 POS 变种。&lt;/p&gt;&lt;p&gt;后来 NXT 社区有人提出用 DAG 的拓扑结构来存储区块，解决区块链的效率问题。区块链只有一条单链，打包出块无法并发执行。如果改变区块的链式存储结构，变成 DAG 的网状拓扑可以并发写入。在区块打包时间不变的情况下，网络中可以并行打包 N 个区块，网络中的交易就可以容纳 N 倍。&lt;/p&gt;&lt;p&gt;此时 DAG 跟区块链的结合依旧停留在类似侧链的解决思路，交易打包可以并行在不同的分支链条进行，达到提升性能的目的。此时 DAG 还是有区块的概念。&lt;/p&gt;&lt;p&gt;2015年9月，Sergio Demian Lerner 发表了 《DagCoin: a cryptocurrency without blocks》一文，提出了 DAG-Chain 的概念，首次把 DAG 网络从区块打包这样粗粒度提升到了基于交易层面，但 DagCoin 本身是一篇论文，没有代码实现。&lt;/p&gt;&lt;p&gt;DagCoin 的思路，让每一笔交易都直接参与维护全网的交易顺序。交易发起后，直接广播全网，跳过打包区块阶段，达到所谓的 Blockless。这样省去了打包交易出块的时间。如前文提到的，DAG 最初跟区块链的结合就是为了解决效率问题，现在不用打包确认，交易发起后直接广播网络确认，理论上效率得到了质的飞跃。DAG 进一步演变成了完全抛弃区块链的一种解决方案。&lt;/p&gt;&lt;p&gt;2016 年 7 月，基于 Bitcointalk 论坛公布的创世贴，IOTA 横空出世，随后 ByteBall 也闪亮登场，IOTA 和 Byteball 是头一次 DAG 网络真正技术实现，也是此领域最耀眼的领军者；此时，号称无块之链、独树一帜的 DAG 链家族雏形基本形成。&lt;/p&gt;&lt;p&gt;一句话来概括：&lt;strong&gt;DAG是面向未来的新一代区块链，从图论拓扑模型宏观看，从单链进化到树状和网状、从区块粒度细化到交易粒度、从单点跃迁到并发写入，这是区块链从容量到速度的一次革新。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;=== &#34;核心特点&#34;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;1. 非线性结构：交易（或区块）之间通过引用（指针）相互连接，形成网状图，而非单链。每个新交易需要引用多个历史交易的哈希值（类似“确认”前序交易；2. 有向性：图中的边具有方向性（例如，交易 A 引用交易 B，则边为 $A \rightarrow B$，不可以反向引用）；3. 无环性：不允许出现循环依赖（例如，交易 A 引用交易 B，交易 B 引用交易 C，交易 C 引用交易 A，则形成一个循环），确保数据一致性。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;=== &#34;与传统区块链相比&#34;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;|特性|传统区块链|DAG||:---:|:---:|:---:||结构|线性链式结构|网状拓扑结构||交易确认方式|顺序打包，线性链式结构，需要多个区块确认|并行处理，网状结构，交易之间相互引用，无需多个区块确认||吞吐量|受限于区块大小和出块速度|理论上可以无限扩展||延迟|高（需要等待区块确认）|低（交易即时传播）||典型应用|比特币、以太坊|IOTA、Nano、Hedera Hashgraph|&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;=== &#34;工作原理&#34;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;1. 交易创建：用户发起交易时，需引用多个已确认的历史交易（作为“基础”）。引用越多，交易的可信度越高（类似共识机制）。2. 交易传播：新交易广播到网络，其他节点验证其引用的历史交易是否有效。验证通过后，交易被加入DAG网络。3. 冲突解决：若两个交易互相矛盾（例如双花攻击），DAG通过​​拓扑排序​​或​​共识算法​​（如Tangle）决定最终状态。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;=== &#34;优势&#34;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;1. 高扩展：无需矿工打包区块，交易可并行处理，适合高频场景（如物联网支付）；2. 低延迟：交易即确认，无需等待区块生成；3. 去中心化：节点间直接交互，减少对中心化矿池对依赖。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;=== &#34;挑战&#34;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;1. 数据存储：网状结构可能导致存储需求指数级增长；2. 双花攻击风险：若恶意用户持续发起冲突交易，可能破坏网络一致性（需依赖强共识机制）；3. 复杂性：开发难度高于传统区块链，需设计高效的冲突检测和解决算法。&lt;/code&gt;&lt;/pre&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/05/06/</link> <pubDate>Tue, 06 May 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/05/06/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/05/06/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/05/06.png" type="image/png" length="79695" /> </item> <item> <title>什么是通货膨胀？</title> <author>Cloaks</author> <category>炒股养家</category> <description>&lt;h1&gt;什么是通货膨胀？&lt;/h1&gt;&lt;p&gt;通货膨胀（Inflation） 是指一个经济体中商品和服务的价格总水平在一段时间内持续、普遍上涨的现象。简单来说，就是“钱变毛了”——同样数量的货币能买到的东西变少了。&lt;/p&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/05/05-1/</link> <pubDate>Mon, 05 May 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/05/05-1/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/05/05-1/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/05/05-1.png" type="image/png" length="77371" /> </item> <item> <title>农产品价格和通胀的关系</title> <author>Cloaks</author> <category>炒股养家</category> <description>&lt;h1&gt;农产品价格和通胀的关系&lt;/h1&gt;&lt;p&gt;农产品价格上涨之所以会引发通货膨胀，是因为农产品在经济体中具有基础性地位，其价格波动会通过多种渠道传导至整体物价水平。以下是具体机制和逻辑链的详细分析：&lt;/p&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/05/05-2/</link> <pubDate>Mon, 05 May 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/05/05-2/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/05/05-2/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/05/05-2.png" type="image/png" length="78329" /> </item> <item> <title>零知识证明（Zero-Knowledge Proof, ZKP）详解</title> <author>Cloaks</author> <category>区块链</category> <description>&lt;h1&gt;零知识证明（Zero-Knowledge Proof, ZKP）详解&lt;/h1&gt;&lt;h2&gt;&lt;strong&gt;一、核心概念&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;零知识证明&lt;/strong&gt; 是一种密码学协议，允许证明者（Prover）向验证者（Verifier）证明某个命题为真，而无需透露任何与该命题相关的额外信息。其核心目标是 &lt;strong&gt;在保证隐私的前提下验证真实性&lt;/strong&gt;。&lt;/p&gt;&lt;h2&gt;...&lt;/h2&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/04/11/</link> <pubDate>Fri, 11 Apr 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/04/11/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/04/11/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/04/11.png" type="image/png" length="87863" /> </item> <item> <title>Components</title> <author>Cloaks</author> <category>札记</category> <category>转载</category> <description>&lt;h1&gt;Components&lt;/h1&gt;&lt;p&gt;Components are the units of deployment. They are the smallest entities that can be deployed as part of a system. In Java, they are jar files. In Ruby, they are gem files. In .Net, they are DLLs. In compiled languages, they are aggregations of binary files. In interpreted languages, they are aggregations of source files. In all languages, they are the granule of deployment.&lt;/p&gt;&lt;p&gt;Components can be linked together into a single executable. Or they can be aggregated together into a single archive, such as a .war file. Or they can be independently deployed as separate dynamically loaded plugins, such as.jar or .dll or .exe files. Regardless of how they are eventually deployed, well-designed components always retain the ability to be independently deployable and, therefore, independently developable.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;编辑于 2025-03-31&lt;/p&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/03/31/</link> <pubDate>Mon, 31 Mar 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/03/31/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/03/31/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/03/31.png" type="image/png" length="66445" /> </item> <item> <title>高频 R/W 场景下的性能设计方案</title> <author>Cloaks</author> <category>区块链</category> <description>&lt;h1&gt;高频 &lt;code&gt;R/W&lt;/code&gt; 场景下的性能设计方案&lt;/h1&gt;&lt;p&gt;对于这个问题我们需要回归到计算机读写的核心上，计算机的读写速度是有限的，所以需要把数据缓存起来，来提高读写速度。为什么要使用缓存呢？从硬件角度我们知道计算机是有多级缓存架构的，每一级存储设备的读写速度是指数级下降的，越靠近终端存储设备（机械硬盘、固态硬盘）其读写速度越慢，越靠近 CPU 的存储设备其读写速度越快。&lt;/p&gt;&lt;p&gt;缓存是一个有着更快的查询速度的存储技术，这里的更快是指比起从初始的数据源查询（比如数据库，以下都称作数据库）而言。我们经常会把频繁请求的或是耗时计算的数据缓存起来，在程序收到请求这些数据的时候可以直接从缓存中查询数据返回给客户端来提高系统的吞吐量，现在我们来看看有哪些缓存模式可以考虑。&lt;/p&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/03/27/</link> <pubDate>Thu, 27 Mar 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/03/27/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/03/27/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/03/27.png" type="image/png" length="86589" /> </item> <item> <title>2025-03-23 有感</title> <author>Cloaks</author> <category>札记</category> <description>&lt;h1&gt;2025-03-23 有感&lt;/h1&gt;&lt;p&gt;绕着困难走的人永远不会成为成功的人。一个成功的人，他是主动迎接挑战的人，因为他要开辟新赛道，他如同走在沙漠当中一样，这是任正非的话。&lt;/p&gt;&lt;p&gt;因为没有人会给你指明未来的方向，需要你去开辟新赛道，引领未来发展的方向，这才是伟大的成功者。&lt;/p&gt;&lt;p&gt;所以人呐，是否能成为一个对社会有贡献的人，一是要...&lt;/p&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/03/23/</link> <pubDate>Sun, 23 Mar 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/03/23/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/03/23/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/03/23.png" type="image/png" length="70136" /> </item> <item> <title>比特币的创新设计</title> <author>Cloaks</author> <category>区块链</category> <description>&lt;h1&gt;比特币的创新设计&lt;/h1&gt;&lt;p&gt;比特币在创新上提出了很多亮点，值得我们去学习。主要考虑了避免作恶、负反馈调节和共识机制三个方面。&lt;/p&gt;&lt;h2&gt;避免作恶&lt;/h2&gt;&lt;p&gt;避免作恶基于经济博弈原理。在一个开放的网络中，无法通过技术手段来保证每个人都是合作的。但是可以通过经济博弈来让合作者受益，让非合作者遭受损失和风险。&lt;/p&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/03/20/</link> <pubDate>Thu, 20 Mar 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/03/20/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/03/20/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/03/20.png" type="image/png" length="75073" /> </item> <item> <title>分布式系统的核心问题</title> <author>Cloaks</author> <category>区块链</category> <description>&lt;h1&gt;分布式系统的核心问题&lt;/h1&gt;&lt;p&gt;分布式系统是计算机科学中十分重要的一个研究领域。随着现代计算机集群规模的不断增长，所处理的数据量越来越大，同时对于性能、可靠性的要求越来越高，分布式系统相关技术已经变得越来越重要，起到的作用也越来越关键。&lt;/p&gt;&lt;p&gt;分布式系统中如何保证共识是个经典的技术问题，无论在学术上还是工程上都存在很高的研究价值。令人遗憾地是，理想的（各项指标均最优）解决方案并不存在。在现实各种约束条件下，往往需要通过牺牲掉某些需求，来设计出满足特定场景的协议。&lt;/p&gt;&lt;p&gt;实际上，工程领域中不少问题都不存在一劳永逸的通用解法；而实用的解决思路是，合理地在实际需求和条件限制之间进行灵活的取舍。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;更新于 2025-03-18 15:26&lt;/p&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/03/14/</link> <pubDate>Fri, 14 Mar 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/03/14/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/03/14/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/03/14.png" type="image/png" length="83460" /> </item> <item> <title>PBFT（Practical Byzantine Fault Tolerance）共识算法</title> <author>Cloaks</author> <category>区块链</category> <description>&lt;h1&gt;PBFT（Practical Byzantine Fault Tolerance）共识算法&lt;/h1&gt;&lt;p&gt;PBFT是 Practical Byzantine Fault Tolerance 的缩写，意为实用拜占庭容错算法。该算法是 Miguel Castro（卡斯特罗）和Barbara Liskov（利斯科夫）在 1999 年提出来的，解决了原始拜占庭容错算法效率不高的问题，将算法复杂度由指数级降低到多项式级，使得拜占庭容错算法在实际系统应用中变得可行。该论文发表在1999年的操作系统设计与实现国际会议上（&lt;a href=&#34;https://www.alipan.com/s/smLoCoGMbci&#34;&gt;OSDI99&lt;/a&gt;）。没错，这个 Loskov 就是提出著名的里氏替换原则（LSP）的人，2008年图灵奖得主。&lt;/p&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/03/12-1/</link> <pubDate>Wed, 12 Mar 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/03/12-1/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/03/12-1/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/03/12-1.png" type="image/png" length="91737" /> </item> <item> <title>拜占庭问题解析</title> <author>Cloaks</author> <category>区块链</category> <description>&lt;h1&gt;拜占庭问题解析&lt;/h1&gt;&lt;p&gt;拜占庭问题（Byzantine Generals Problem）是分布式系统领域的一个经典问题，旨在解决 &lt;strong&gt;在存在不可靠或恶意节点&lt;/strong&gt; 的情况下，如何让分布式系统中的各个参与者（节点）就某一决策达成一致行动。以下是系统性解析：&lt;/p&gt;&lt;h2&gt;一、问题起源与核心场景&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;军事隐喻 &lt;/p&gt;&lt;p&gt;莱斯利·兰伯特（Leslie Lamport）在1982年提出该问题时，以拜占庭帝国（东罗马帝国）的将军围攻敌城为背景： &lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;目标&lt;/strong&gt;：所有忠诚将军需在同一时间发起总攻或撤退。 &lt;/li&gt;&lt;li&gt;&lt;strong&gt;挑战&lt;/strong&gt;：部分将军可能是叛徒，会向不同阵营发送矛盾指令（如“进攻”或“撤退”）。 &lt;/li&gt;&lt;li&gt;&lt;strong&gt;关键约束&lt;/strong&gt;： &lt;ul&gt;&lt;li&gt;每个将军只能通过信使传递口头命令。 &lt;/li&gt;&lt;li&gt;信使可能被叛徒截获或篡改。 &lt;/li&gt;&lt;li&gt;最终所有忠诚将军必须采取相同行动，否则战斗失败。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/03/12-2/</link> <pubDate>Wed, 12 Mar 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/03/12-2/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/03/12-2/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/03/12-2.png" type="image/png" length="70546" /> </item> <item> <title>高级架构师高频题型总结</title> <author>Cloaks</author> <category>高级架构师</category> <description>&lt;h1&gt;高级架构师高频题型总结&lt;/h1&gt;&lt;h2&gt;选择题&lt;/h2&gt;&lt;h3&gt;面向对象&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;在 UML 用例图中，参与者之间存在 __ 关系。&lt;/p&gt;&lt;p&gt;A. 聚合 B. 包含 C. 继承/泛化 (✅) D. 扩展&lt;/p&gt;&lt;p&gt;??? note&lt;/p&gt;&lt;pre&gt;&lt;code&gt;用例图描述了一组用例、参与者以及它们之间的关系。这里没考察用例之间的关系，而是考察了参与者之间的关系![](images/image-29.png)参与者、国际留学生与参与者、学生之间的关系是泛化关系* 用例与参与者之间有 **扩展和包含** 关系* 参与者与用例之间有 **关联** 关系* 用例与用例、参与者与参与者之间有 **泛化** 关系![](images/image-32.png)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据资产的特性包括：可控制、可量化、可变现、虚拟性、共享性、时效性、安全性、交换性和规模性。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/03/12/</link> <pubDate>Wed, 12 Mar 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/03/12/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/03/12/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/03/12.png" type="image/png" length="77393" /> </item> <item> <title>关于组合问题的算法设计</title> <author>Cloaks</author> <category>算法</category> <description>&lt;h1&gt;关于组合问题的算法设计&lt;/h1&gt;&lt;p&gt;昨天做了力扣编号为 &lt;a href=&#34;https://leetcode.cn/problems/the-number-of-beautiful-subsets/description/&#34;&gt;&lt;code&gt;2597&lt;/code&gt;&lt;/a&gt; 的算法题，需要遍历数组的所有集合，并从集合中选出符合要求的集合。了解后发现需要使用回溯算法解决，特此记录。&lt;/p&gt;&lt;p&gt;递归 + 回溯是一种非常强大的算法设计技巧，特别适合解决组合问题（如遍历所有子集）。它的核心思路是通过递归探索所有的可能，并通过回溯撤销选择，从而覆盖所有可能的组合。&lt;/p&gt;&lt;p&gt;它是如何工作的，本质上子集问题的目标是找到所有可能的自己。对于一个长度为 $n$ 的数组，总共有 $2n$ 个子集（包括空集）。比如 ${1, 2, 3}$ 的子集是：&lt;/p&gt;&lt;p&gt;$${1}、{2}、{3}、{1, 2}、{1, 3}、{2, 3}、 {}$$&lt;/p&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/03/8/</link> <pubDate>Sat, 08 Mar 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/03/8/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/03/8/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/03/8.png" type="image/png" length="76349" /> </item> <item> <title>爱的艺术：心理学大师佛罗姆跨时代不朽经典</title> <author>Cloaks</author> <category>读书笔记</category> <description>&lt;h1&gt;爱的艺术：心理学大师佛罗姆跨时代不朽经典&lt;/h1&gt;&lt;p&gt;!!! Tips&lt;/p&gt;&lt;pre&gt;&lt;code&gt;下载地址：[爱的艺术](https://www.alipan.com/s/BYub9T77JLD)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先就被序言中的这句话吸引住了：&lt;code&gt;爱某一个人并不只是一种强烈感情，它还是一个决定、一个判断和一个承诺。&lt;/code&gt; 如果当初懵懂的自己能够早些明白，也许就不会再有那么多遗憾了。&lt;/p&gt;&lt;p&gt;记得大学时选修了政法系的一门课程叫《爱情伦理学》，老师是一位很和蔼的小老头，回头看老师非常关注当时的社会现象和社会问题，能够感受到老师非常想让学生树立正确的爱情观，一切从娃娃抓起。&lt;/p&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/03/3/</link> <pubDate>Mon, 03 Mar 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/03/3/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/03/3/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/03/3.png" type="image/png" length="76105" /> </item> <item> <title>使用 C++ 实现 COM 组件的示例</title> <category>高级架构师</category> <description>&lt;h1&gt;&lt;strong&gt;使用 C++ 实现 COM 组件的示例&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;COM（Component Object Model）是微软提出的用于构建组件化应用程序的标准。COM 允许不同编程语言编写的组件进行互操作。本文将展示如何用 C++ 创建和使用 COM 组件，涵盖接口定义、组件实现、引用计数、对象创建等基本概念。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;1. 定义接口&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在 COM 编程中，接口是定义组件之间交互的核心部分。所有的 COM 接口都必须继承自 &lt;code&gt;IUnknown&lt;/code&gt; 接口，它提供了基本的引用计数和接口查询功能。&lt;/p&gt;&lt;p&gt;下面我们定义一个简单的接口 &lt;code&gt;IHello&lt;/code&gt;，它包含一个方法 &lt;code&gt;Hello&lt;/code&gt; 用于打印消息。&lt;/p&gt;&lt;p&gt;```cpp// IHello.h&lt;/p&gt;&lt;h1&gt;ifndef IHELLO_H&lt;/h1&gt;&lt;h1&gt;define IHELLO_H&lt;/h1&gt;&lt;h1&gt;include &lt;objbase.h&gt;&lt;/h1&gt;&lt;p&gt;// 定义 IHello 接口class IHello : public IUnknown {public: virtual void Hello() = 0;};&lt;/p&gt;&lt;p&gt;// 定义 IHello 的 GUID// {D77A85A0-68F7-4F0C-9B5A-A6D84236A2D1}DEFINE_GUID(IID_IHello, 0xd77a85a0, 0x68f7, 0x4f0c, 0x9b, 0x5a, 0xa6, 0xd8, 0x42, 0x36, 0xa2, 0xd1);&lt;/p&gt;&lt;h1&gt;endif&lt;/h1&gt;&lt;p&gt;```&lt;/p&gt;&lt;p&gt;在这段代码中，我们定义了一个接口 &lt;code&gt;IHello&lt;/code&gt;，它继承自 &lt;code&gt;IUnknown&lt;/code&gt; 并包含一个 &lt;code&gt;Hello&lt;/code&gt; 方法。&lt;code&gt;DEFINE_GUID&lt;/code&gt; 宏用于生成接口的唯一标识符（GUID），该标识符在 COM 中用于区分不同的接口。&lt;/p&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/02/21-1/</link> <pubDate>Fri, 21 Feb 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/02/21-1/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/02/21-1/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/02/21-1.png" type="image/png" length="83603" /> </item> <item> <title>深入了解 COM（Component Object Model）</title> <category>高级架构师</category> <description>&lt;h1&gt;&lt;strong&gt;深入了解 COM（Component Object Model）&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;COM（Component Object Model）是微软提出的一种二进制接口标准，允许不同编程语言编写的组件之间进行互操作。它的设计初衷是使得不同的应用程序可以使用和共享不同语言编写的组件。COM 作为一种中间层协议，定义了组件的交互接口，并通过它实现不同组件间的通信。&lt;/p&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/02/21/</link> <pubDate>Fri, 21 Feb 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/02/21/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/02/21/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/02/21.png" type="image/png" length="96173" /> </item> <item> <title>当时只道是寻常</title> <category>札记</category> <description>&lt;h1&gt;当时只道是寻常&lt;/h1&gt;&lt;p&gt;!!! Note &#34;浣溪沙 纳兰容若&#34;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;谁念西风独自凉，萧萧黄叶闭疏窗，沉思往事立残阳。被酒莫惊春睡重，赌书消得泼茶香，当时只道是寻常。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那些我们习以为常的日子，那些眼前的普通人，可能在某一天，都是你人生回忆里的美好，所以朋友啊，珍稀当下，珍惜眼前人。&lt;/p&gt;</description><link>https://www.cloaks.cn/blog/posts/2025/02/17/</link> <pubDate>Mon, 17 Feb 2025 00:00:00 +0000</pubDate><source url="https://www.cloaks.cn/feed_rss_created.xml">Cloaks | Return</source><comments>https://www.cloaks.cn/blog/posts/2025/02/17/#__comments</comments><guid isPermaLink="true">https://www.cloaks.cn/blog/posts/2025/02/17/</guid> <enclosure url="https://www.cloaks.cn/assets/images/social/blog/posts/2025/02/17.png" type="image/png" length="67148" /> </item> </channel></rss>