---
title: å¹¿åº¦ä¼˜å…ˆæœç´¢
date: 2023-02-13 21:26:47
category: ç®—æ³•
---

å¹¿åº¦ä¼˜å…ˆæœç´¢ç®—æ³•ï¼ˆBreadth-First Searchï¼Œç¼©å†™ä¸º BFSï¼‰ï¼Œåˆç§°ä¸ºå®½åº¦ä¼˜å…ˆæœç´¢ï¼Œæ˜¯ä¸€ç§å›¾å½¢æœç´¢ç®—æ³•ã€‚ç®€å•çš„è¯´ï¼ŒBFS æ˜¯ä»æ ¹ç»“ç‚¹å¼€å§‹ï¼Œæ²¿ç€æ ‘çš„å®½åº¦éå†æ ‘çš„ç»“ç‚¹ã€‚å¦‚æœæ‰€æœ‰ç»“ç‚¹å‡è¢«è®¿é—®ï¼Œåˆ™ç®—æ³•ä¸­æ­¢ã€‚

<!-- more -->

## ä¾‹é¢˜

### 102 äºŒå‰æ ‘çš„å±‚åºéå†

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ `root` ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ **å±‚åºéå†** ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚

**ç¤ºä¾‹ 1ï¼š**
![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)
è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
è¾“å‡ºï¼š[[3],[9,20],[15,7]]

**ç¤ºä¾‹ 2ï¼š**

**è¾“å…¥ï¼š** root = [1]
**è¾“å‡ºï¼š** [[1]]

**ç¤ºä¾‹ 3ï¼š** 

**è¾“å…¥ï¼š** root = []
**è¾“å‡ºï¼š** []

**æç¤ºï¼š** 

* æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ `[0, 2000]` å†…
* `$-1000 &lt;= Node.val &lt;= 1000$`

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrder(root *TreeNode) [][]int {
    result := [][]int{}

    if root == nil {
        return result
    }
    // é˜Ÿåˆ—
    queue := []*TreeNode{root}
    for len(queue) != 0 {
        row := []int{}
        for n := len(queue); n > 0; n-- {
            temp := queue[0]
            row = append(row, temp.Val)
            // å‡ºé˜Ÿ
            queue = queue[1:]
            // å­èŠ‚ç‚¹å…¥é˜Ÿ
            if temp.Left != nil {
                queue = append(queue, temp.Left)
            }
            if temp.Right != nil {
                queue = append(queue, temp.Right)
            }
        }
        result = append(result, row)
    }
    return result
}
```

### 733 å›¾åƒæ¸²æŸ“

æœ‰ä¸€å¹…ä»¥ `m x n` çš„äºŒç»´æ•´æ•°æ•°ç»„è¡¨ç¤ºçš„å›¾ç”» `image` ï¼Œå…¶ä¸­ `image[i][j]` è¡¨ç¤ºè¯¥å›¾ç”»çš„åƒç´ å€¼å¤§å°ã€‚

ä½ ä¹Ÿè¢«ç»™äºˆä¸‰ä¸ªæ•´æ•°  `sr`  ,  `sc`  å’Œ  `newColor`  ã€‚ä½ åº”è¯¥ä»åƒç´  `image[sr][sc]` å¼€å§‹å¯¹å›¾åƒè¿›è¡Œ ä¸Šè‰²**å¡«å……**  ã€‚

ä¸ºäº†å®Œæˆ** ä¸Šè‰²å·¥ä½œ**  ï¼Œä»åˆå§‹åƒç´ å¼€å§‹ï¼Œè®°å½•åˆå§‹åæ ‡çš„ **ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘ä¸Š**  åƒç´ å€¼ä¸åˆå§‹åæ ‡ç›¸åŒçš„ç›¸è¿åƒç´ ç‚¹ï¼Œæ¥ç€å†è®°å½•è¿™å››ä¸ªæ–¹å‘ä¸Šç¬¦åˆæ¡ä»¶çš„åƒç´ ç‚¹ä¸ä»–ä»¬å¯¹åº” **å››ä¸ªæ–¹å‘ä¸Š**  åƒç´ å€¼ä¸åˆå§‹åæ ‡ç›¸åŒçš„ç›¸è¿åƒç´ ç‚¹ï¼Œâ€¦â€¦ï¼Œé‡å¤è¯¥è¿‡ç¨‹ã€‚å°†æ‰€æœ‰æœ‰è®°å½•çš„åƒç´ ç‚¹çš„é¢œè‰²å€¼æ”¹ä¸º `newColor` ã€‚

æœ€åè¿”å›ç»è¿‡ä¸Šè‰²æ¸²æŸ“åçš„å›¾åƒã€‚

**ç¤ºä¾‹ 1:** 

![](https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg)

**è¾“å…¥:**  image = [[1,1,1],[1,1,0],[1,0,1]]ï¼Œsr = 1, sc = 1, newColor = 2
**è¾“å‡º:**  [[2,2,2],[2,2,0],[2,0,1]]
**è§£æ:**  åœ¨å›¾åƒçš„æ­£ä¸­é—´ï¼Œ(åæ ‡(sr,sc)=(1,1)),åœ¨è·¯å¾„ä¸Šæ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„åƒç´ ç‚¹çš„é¢œè‰²éƒ½è¢«æ›´æ”¹æˆ2ã€‚
æ³¨æ„ï¼Œå³ä¸‹è§’çš„åƒç´ æ²¡æœ‰æ›´æ”¹ä¸º2ï¼Œå› ä¸ºå®ƒä¸æ˜¯åœ¨ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘ä¸Šä¸åˆå§‹ç‚¹ç›¸è¿çš„åƒç´ ç‚¹ã€‚

**ç¤ºä¾‹ 2:** 

**è¾“å…¥:**  image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2
**è¾“å‡º:**  [[2,2,2],[2,2,2]]

**æç¤º:** 

* `m == image.length` 
* `n == image[i].length` 
* `1 &lt;= m, n &lt;= 50` 
* `0 &lt;= image[i][j], newColor &lt; 2<sup>16</sup>` 
* `0 &lt;= sr &lt;m` 
* `0 &lt;= sc &lt;n` 

```go
func floodFill(image [][]int, sr int, sc int, color int) [][]int {
    dir := [][]int{
        {-1, 0},
        {1, 0},
        {0, -1},
        {0, 1},
    }
    origin := image[sr][sc]
    if origin == color {
        return image
    }
    // åˆå§‹åŒ–é˜Ÿåˆ—
    queue := [][]int{{sr, sc}}
    for len(queue) > 0 {
        pos := queue[0]
        currX := pos[0]
        currY := pos[1]

        for _, v := range dir {
            // å¦‚æœå››ä¸ªæ–¹å‘åƒç´ ç›¸è¿ï¼Œå…¥é˜Ÿ
            nextX := pos[0] + v[0]
            nextY := pos[1] + v[1]
            if isPos(image, nextX, nextY) && image[nextX][nextY] != -1 && image[nextX][nextY] == origin {
                image[nextX][nextY] = -1
                queue = append(queue, []int{nextX, nextY})
            }
        }
        // å¡«è‰²ï¼Œå‡ºé˜Ÿ
        image[currX][currY] = color
        queue = queue[1:]
    }
    return image
}

func isPos(image [][]int, x int, y int) bool {
    if x >= 0 && x < len(image) && y >= 0 && y < len(image[0]) {
        return true
    }
    return false
}
```

### 695 å²›å±¿å¤§å°

ç»™ä½ ä¸€ä¸ªå¤§å°ä¸º  `m x n`  çš„äºŒè¿›åˆ¶çŸ©é˜µ  `grid`  ã€‚

**å²›å±¿** æ˜¯ç”±ä¸€äº›ç›¸é‚»çš„ `1` (ä»£è¡¨åœŸåœ°) æ„æˆçš„ç»„åˆï¼Œè¿™é‡Œçš„ã€Œç›¸é‚»ã€è¦æ±‚ä¸¤ä¸ª  `1`  å¿…é¡»åœ¨ **æ°´å¹³æˆ–è€…ç«–ç›´çš„å››ä¸ªæ–¹å‘ä¸Š ** ç›¸é‚»ã€‚ä½ å¯ä»¥å‡è®¾ `grid`  çš„å››ä¸ªè¾¹ç¼˜éƒ½è¢«  `0` ï¼ˆä»£è¡¨æ°´ï¼‰åŒ…å›´ç€ã€‚

å²›å±¿çš„é¢ç§¯æ˜¯å²›ä¸Šå€¼ä¸º  `1`  çš„å•å…ƒæ ¼çš„æ•°ç›®ã€‚

è®¡ç®—å¹¶è¿”å›  `grid`  ä¸­æœ€å¤§çš„å²›å±¿é¢ç§¯ã€‚å¦‚æœæ²¡æœ‰å²›å±¿ï¼Œåˆ™è¿”å›é¢ç§¯ä¸º  `0`  ã€‚

**ç¤ºä¾‹ 1ï¼š** 

![](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)

**è¾“å…¥ï¼š** grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
**è¾“å‡ºï¼š** 6
**è§£é‡Šï¼š** ç­”æ¡ˆä¸åº”è¯¥æ˜¯  `11`  ï¼Œå› ä¸ºå²›å±¿åªèƒ½åŒ…å«æ°´å¹³æˆ–å‚ç›´è¿™å››ä¸ªæ–¹å‘ä¸Šçš„  `1`  ã€‚

**ç¤ºä¾‹ 2ï¼š** 

**è¾“å…¥ï¼š** grid = [[0,0,0,0,0,0,0,0]]
**è¾“å‡ºï¼š** 0

**æç¤ºï¼š** 

* `m == grid.length` 
* `n == grid[i].length` 
* `1 &lt;= m, n &lt;= 50` 
* `grid[i][j]`  ä¸º  `0`  æˆ–  `1` 

```go
func maxAreaOfIsland(grid [][]int) int {
    result := 0

    for i, row := range grid {
        for j, v := range row {
            if v == 1 {
                temp := search(grid, i, j)
                if result < temp {
                    result = temp
                }
            }
        }
    }
    return result
}

func search(grid [][]int, x int, y int) int {
    result := 0
    dir := [][]int{
        {-1, 0},
        {1, 0},
        {0, -1},
        {0, 1},
    }

    // åˆå§‹åŒ–é˜Ÿåˆ—
    queue := [][]int{{x, y}}
    for len(queue) > 0 {
        pos := queue[0]
        currX := pos[0]
        currY := pos[1]

        for _, v := range dir {
            // å¦‚æœå››ä¸ªæ–¹å‘åƒç´ ç›¸è¿ï¼Œå…¥é˜Ÿ
            nextX := currX + v[0]
            nextY := currY + v[1]
            grid[currX][currY] = -1
            if isPos(grid, nextX, nextY) && grid[nextX][nextY] == 1 {
                grid[nextX][nextY] = -1
                queue = append(queue, []int{nextX, nextY})
            }
        }

        result++
        queue = queue[1:]
    }
    return result
}

func isPos(image [][]int, x int, y int) bool {
    if x >= 0 && x < len(image) && y >= 0 && y < len(image[0]) {
        return true
    }
    return false
}
```

### 116 å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ

ç»™å®šä¸€ä¸ª**å®Œç¾äºŒå‰æ ‘** ï¼Œå…¶æ‰€æœ‰å¶å­èŠ‚ç‚¹éƒ½åœ¨åŒä¸€å±‚ï¼Œæ¯ä¸ªçˆ¶èŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ã€‚äºŒå‰æ ‘å®šä¹‰å¦‚ä¸‹ï¼š

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}

å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œè®©è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ã€‚å¦‚æœæ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œåˆ™å°† next æŒ‡é’ˆè®¾ç½®ä¸º  `NULL` ã€‚

åˆå§‹çŠ¶æ€ä¸‹ï¼Œæ‰€æœ‰next æŒ‡é’ˆéƒ½è¢«è®¾ç½®ä¸º  `NULL` ã€‚

**ç¤ºä¾‹ 1ï¼š** 

![](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)

**è¾“å…¥ï¼š** root = [1,2,3,4,5,6,7]
**è¾“å‡ºï¼š** [1,#,2,3,#,4,5,6,7,#]
**è§£é‡Šï¼š** ç»™å®šäºŒå‰æ ‘å¦‚å›¾ A æ‰€ç¤ºï¼Œä½ çš„å‡½æ•°åº”è¯¥å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œä»¥æŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œå¦‚å›¾ B æ‰€ç¤ºã€‚åºåˆ—åŒ–çš„è¾“å‡ºæŒ‰å±‚åºéå†æ’åˆ—ï¼ŒåŒä¸€å±‚èŠ‚ç‚¹ç”± next æŒ‡é’ˆè¿æ¥ï¼Œ'#' æ ‡å¿—ç€æ¯ä¸€å±‚çš„ç»“æŸã€‚

<meta charset="UTF-8" />

**ç¤ºä¾‹ 2:** 

**è¾“å…¥ï¼š** root = []
**è¾“å‡ºï¼š** []

**æç¤ºï¼š** 

* æ ‘ä¸­èŠ‚ç‚¹çš„æ•°é‡åœ¨<meta charset="UTF-8" /> `[0, 2<sup>12</sup>- 1]` èŒƒå›´å†…
* `-1000 &lt;= node.val &lt;= 1000` 

**è¿›é˜¶ï¼š** 

	*ä½ åªèƒ½ä½¿ç”¨å¸¸é‡çº§é¢å¤–ç©ºé—´ã€‚
	*ä½¿ç”¨é€’å½’è§£é¢˜ä¹Ÿç¬¦åˆè¦æ±‚ï¼Œæœ¬é¢˜ä¸­é€’å½’ç¨‹åºå ç”¨çš„æ ˆç©ºé—´ä¸ç®—åšé¢å¤–çš„ç©ºé—´å¤æ‚åº¦ã€‚

```go
/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Left *Node
 *     Right *Node
 *     Next *Node
 * }
 */

func connect(root *Node) *Node {
    if root == nil {
        return root
    }

    // ä»¥ nil ä½œä¸ºæ¯ä¸€å±‚çš„åˆ†å‰²ç‚¹ï¼Œå¦‚æœæ£€æµ‹åˆ° nil é‡ç½®é˜Ÿåˆ—
    queue := []*Node{root, nil}
    for {
        for i, v := range queue {
            if v == nil {
                // é“¾æ¥
                queue[i-1].Next = nil
                // å‡ºé˜Ÿ
                queue = queue[i+1:]
                queue = append(queue, nil)
                break
            } else {
                // é“¾æ¥
                v.Next = queue[i+1]
            }

            // å…¥é˜Ÿ
            if v.Left != nil && v.Right != nil {
                queue = append(queue, v.Left)
                queue = append(queue, v.Right)
            }
        }

        // ä¸­æ­¢
        if queue[0] == nil {
            break
        }
    }
    return root
}
```

### ğŸ’£ 542 01 çŸ©é˜µ

ç»™å®šä¸€ä¸ªç”±  `0`  å’Œ  `1`  ç»„æˆçš„çŸ©é˜µ  `mat` Â ï¼Œè¯·è¾“å‡ºä¸€ä¸ªå¤§å°ç›¸åŒçš„çŸ©é˜µï¼Œå…¶ä¸­æ¯ä¸€ä¸ªæ ¼å­æ˜¯  `mat`  ä¸­å¯¹åº”ä½ç½®å…ƒç´ åˆ°æœ€è¿‘çš„  `0`  çš„è·ç¦»ã€‚

ä¸¤ä¸ªç›¸é‚»å…ƒç´ é—´çš„è·ç¦»ä¸º  `1`  ã€‚

**ç¤ºä¾‹ 1ï¼š**

![](https://pic.leetcode-cn.com/1626667201-NCWmuP-image.png)

**è¾“å…¥ï¼š** mat =** ** [[0,0,0],[0,1,0],[0,0,0]]
**è¾“å‡ºï¼š** [[0,0,0],[0,1,0],[0,0,0]]

**ç¤ºä¾‹ 2ï¼š** 

![](https://pic.leetcode-cn.com/1626667205-xFxIeK-image.png)

**è¾“å…¥ï¼š** mat = [[0,0,0],[0,1,0],[1,1,1]]
**è¾“å‡ºï¼š** [[0,0,0],[0,1,0],[1,2,1]]

**æç¤ºï¼š** 

* `m == mat.length` 
* `n == mat[i].length` 
* `1 <= m, n <= 10<sup>4</sup>` 
* `1 <= m * n <= 10<sup>4</sup>` 
* `mat[i][j] is either 0 or 1.` 
* `mat`  ä¸­è‡³å°‘æœ‰ä¸€ä¸ª  `0Â ` 

```go
func updateMatrix(matrix [][]int) [][]int {

    n, m := len(matrix), len(matrix[0])
    queue := make([][]int, 0)
    for i := 0; i < n; i++ {    // æŠŠ0å…¨éƒ¨å­˜è¿›é˜Ÿåˆ—ï¼Œåé¢ä»é˜Ÿåˆ—ä¸­å–å‡ºæ¥ï¼Œåˆ¤æ–­æ¯ä¸ªè®¿é—®è¿‡çš„èŠ‚ç‚¹çš„ä¸Šä¸‹å·¦å³ï¼Œç›´åˆ°æ‰€æœ‰çš„èŠ‚ç‚¹éƒ½è¢«è®¿é—®è¿‡ä¸ºæ­¢ã€‚
        for j := 0; j < m; j++ {
            if matrix[i][j] == 0 {
                point := []int{i, j}
                queue = append(queue, point)
            } else {
                matrix[i][j] = -1
            }
        }
    }
    direction := [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}

    for len(queue) > 0 {  // è¿™é‡Œå°±æ˜¯ BFS æ¨¡æ¿æ“ä½œäº†ã€‚
        point := queue[0]
        queue = queue[1:]
        for _, v := range direction {
            x := point[0] + v[0]
            y := point[1] + v[1]
            if x >= 0 && x < n && y >= 0 && y < m && matrix[x][y] == -1 {
                matrix[x][y] = matrix[point[0]][point[1]] + 1
                queue = append(queue, []int{x, y})
            }
        }
    }
    
    return matrix
}
```

### 994 è…çƒ‚çš„æ©˜å­

åœ¨ç»™å®šçš„ `m x n` ç½‘æ ¼ `grid` ä¸­ï¼Œæ¯ä¸ªå•å…ƒæ ¼å¯ä»¥æœ‰ä»¥ä¸‹ä¸‰ä¸ªå€¼ä¹‹ä¸€ï¼š

* å€¼ `0` ä»£è¡¨ç©ºå•å…ƒæ ¼ï¼›
* å€¼ `1` ä»£è¡¨æ–°é²œæ©˜å­ï¼›
* å€¼ `2` ä»£è¡¨è…çƒ‚çš„æ©˜å­ã€‚

æ¯åˆ†é’Ÿï¼Œè…çƒ‚çš„æ©˜å­**å‘¨å›´4 ä¸ªæ–¹å‘ä¸Šç›¸é‚»**  çš„æ–°é²œæ©˜å­éƒ½ä¼šè…çƒ‚ã€‚

è¿”å›ç›´åˆ°å•å…ƒæ ¼ä¸­æ²¡æœ‰æ–°é²œæ©˜å­ä¸ºæ­¢æ‰€å¿…é¡»ç»è¿‡çš„æœ€å°åˆ†é’Ÿæ•°ã€‚å¦‚æœä¸å¯èƒ½ï¼Œè¿”å› `-1`ã€‚

**ç¤ºä¾‹ 1ï¼š** 

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png)

**è¾“å…¥ï¼š** grid = [[2,1,1],[1,1,0],[0,1,1]]
**è¾“å‡ºï¼š** 4

**ç¤ºä¾‹ 2ï¼š** 

**è¾“å…¥ï¼š** grid = [[2,1,1],[0,1,1],[1,0,1]]
**è¾“å‡ºï¼š** -1
**è§£é‡Šï¼š** å·¦ä¸‹è§’çš„æ©˜å­ï¼ˆç¬¬ 2 è¡Œï¼Œ ç¬¬ 0 åˆ—ï¼‰æ°¸è¿œä¸ä¼šè…çƒ‚ï¼Œå› ä¸ºè…çƒ‚åªä¼šå‘ç”Ÿåœ¨ 4 ä¸ªæ­£å‘ä¸Šã€‚

**ç¤ºä¾‹ 3ï¼š** 

**è¾“å…¥ï¼š** grid = [[0,2]]
**è¾“å‡ºï¼š** 0
**è§£é‡Šï¼š** å› ä¸º 0 åˆ†é’Ÿæ—¶å·²ç»æ²¡æœ‰æ–°é²œæ©˜å­äº†ï¼Œæ‰€ä»¥ç­”æ¡ˆå°±æ˜¯ 0 ã€‚

**æç¤ºï¼š** 

* `m == grid.length` 
* `n == grid[i].length` 
* `1 &lt;= m, n &lt;= 10` 
* `grid[i][j]`  ä»…ä¸º `0` ã€ `1` æˆ– `2` 

```go
func orangesRotting(grid [][]int) int {
    queue := [][]int{}
    for i, row := range grid {
        for j, v := range row {
            if v == 2 {
                queue = append(queue, []int{i,j})
            }
        }
    }

    result := search(grid, queue)

    for _, row := range grid {
        for _, v := range row {
            if v == 1 {
                return -1
            }
        }
    }
    return result
}

var dirs = [][]int{
    {-1, 0},
    {1, 0},
    {0, -1},
    {0, 1},
}

func search(grid [][]int, queue [][]int) int {
    result := 0

    for len(queue) > 0 {
        tempQueue := [][]int{}
        n := len(queue)
        for i := 0; i < n; i++ {
            currX := queue[i][0]
            currY := queue[i][1]

            for _, v := range dirs {
                nextX := currX + v[0]
                nextY := currY + v[1]

                if isPos(grid, nextX, nextY) && grid[nextX][nextY] == 1 {
                    grid[nextX][nextY] = 2
                    tempQueue = append(tempQueue, []int{nextX, nextY})
                }
            }

            if i == len(queue) - 1 {
                queue = tempQueue
            }
        }

        if len(queue) > 0 {
            result++
        }
    }
    return result
}

func isPos(image [][]int, x int, y int) bool {
    if x >= 0 && x < len(image) && y >= 0 && y < len(image[0]) {
        return true
    }
    return false
}
```