---
date: 2024-12-04
authors:
  - cloaks
categories:
  - 读书笔记
  - Build your own database
tags:
  - 翻译
comments: true
# draft: true
---

# B-Tree 和 崩溃恢复

B-Tree 是一个非常棒的数据结构，我们可以从以下几个角度分析：

* 平衡多叉树
* 嵌套数组
* 维护 B+tree
* 持久化

## B-tree as a balanced n-ary tree

### Height-balanced tree

许多实用的二叉树，例如AVL树或RB树，被称为高度平衡树，这意味着树的高度（从根到叶）被限制为 $O(\log(N))$，因此查找是 $O(\log(N))$。

B 树也是高度平衡的；所有叶节点的高度相同。

<!-- more -->

### Generalizing binary trees

n 叉树可以从二叉树推广而来（反之亦然）。一个例子是 2-3-4 树，它是一个 B 树，其中每个节点可以有 2、3 或 4 个子节点。 2-3-4树相当于RB树。不过，我们不会详细介绍，因为它们对于理解 B 树来说并不是必需的。

可视化排序序列 [1, 2, 3, 4, 6, 9, 11, 12] 的 2 层 B+ 树。

```plain
     [1,   4,   9]
     /     |     \
    v      v      v
[1, 2, 3] [4, 6] [9, 11, 12]
```

在B+树中，只有叶子节点包含值，键在内部节点中重复以指示子树的键范围。在此示例中，节点 [1, 4, 9] 表示其 3 个子树位于区间 [1, 4)、[4, 9) 和 [9, +∞) 内。然而，3 个区间只需要 2 个键，因此可以省略第一个键 (1)，3 个区间变为 (-∞, 4)、[4, 9) 和 (9, +∞)。

## B-tree as nest arrays

### Tow-level nested arrays

在不知道RB树或2-3-4树的细节的情况下，可以从排序数组来理解B树。

排序数组的问题是 $O(N)$ 更新。如果我们将数组分成 $m$ 个较小的、不重叠的数组，则更新变为 $O(N/m)$。但我们必须找出首先更新/查询哪个小数组。因此，我们需要另一个对较小数组的引用的排序数组，即 $B+$ 树中的内部节点。

```plain
[[1,2,3], [4,6], [9,11,12]]
```

通过 2 次二分搜索，查找成本仍然是 $O(log N)$。如果我们选择 $m$ 为 $√N$，则更新变为 $O(√N)$，这与 2 级排序数组一样好。

### Multiple levels of nested arrays

$O(√N)$ 对于数据库来说是不可接受的，但是如果我们通过进一步拆分数组来添加更多级别，成本会进一步降低。

假设我们不断分割级别，直到所有数组都不大于常量 s，最终得到 $\log(N/s)$ 个级别，查找成本为 $O(\log(N/s)+\log(s))$，其中仍然是 $O(\log(N))$。

对于插入和删除来说，找到叶子节点后​​，更新叶子节点大多数时候都是常数 $O(s)$。剩下的问题是维持节点不大于 s 并且不为空的不变量。

## Maintaining a B+Tree

更新 B+ 树时要保留的 3 个不变量：

1. 所有叶节点的高度相同。
2. 节点大小受常数限制。
3. 节点不为空。

### Growing a B-tree by splitting nodes

插入叶节点会违反第二个不变量，而叶节点则通过将节点拆分为更小的节点来恢复。

```plain
    parent              parent
   /  |  \     =>      /  | |  \
L1   L2   L6         L1  L3 L4  L6
     *                   *  *
```

叶子节点分裂后，其父节点得到一个新的分支，该分支也可能超出大小限制，因此也可能需要分裂。节点分裂可以传播到根节点，使高度增加 1。

```plain
                        new_root
                          / \
    root                 N1 N2
   /  |  \     =>      /  | |  \
L1   L2   L6         L1  L3 L4  L6
```

这保留了第一个不变量，因为所有叶子的高度同时增加 1。

### Shrinking a B-tree by merging nodes

删除可能会导致空节点。通过将空节点合并到兄弟节点中来恢复第三个不变量。合并与分裂相反。它还可以传播到根节点，因此树的高度可以降低。

在编码 B 树时，可以提前进行合并以减少空间浪费：当非空节点的大小达到下限时，可以合并非空节点。

---
编辑于 2024-12-04 10:14

## B-Tree on disk

您已经可以使用这些原则编写内存中 B 树。但磁盘上的 B 树需要额外的考虑。