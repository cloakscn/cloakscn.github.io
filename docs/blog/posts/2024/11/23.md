---
date: 2024-11-23
authors:
  - cloaks
# categories:
#   - 高级架构师
tags:
  - 翻译
comments: true
draft: true
description: 2013 年 3 月 Docker 的开源发布引发了软件开发行业打包和部署现代应用程序方式的重大转变。在 Docker 发布之后，许多相互竞争、相互补充和相互支持的容器技术也随之诞生，这导致了围绕这一领域的许多炒作和一些幻灭。本系列文章旨在揭示其中的一些困惑，并解释容器在企业中的实际使用情况。
---

# 用不到 100 行 Go 语言构建自己的容器

> 原文地址：[https://www.infoq.com/articles/build-a-container-golang/](https://www.infoq.com/articles/build-a-container-golang/)

2013 年 3 月 Docker 的开源发布引发了软件开发行业打包和部署现代应用程序方式的重大转变。在 Docker 发布之后，许多相互竞争、相互补充和相互支持的容器技术也随之诞生，这导致了围绕这一领域的许多炒作和一些幻灭。本系列文章旨在揭示其中的一些困惑，并解释容器在企业中的实际使用情况。

本系列文章首先介绍了容器背后的核心技术以及开发人员目前的使用情况，然后探讨了在企业中部署容器所面临的核心挑战，例如将容器化集成到持续集成和持续交付管道中，以及加强监控以支持不断变化的工作负载和潜在的瞬时性。本系列最后展望了容器化的未来，并讨论了 unikernels 目前在前沿组织中发挥的作用。

<!-- more -->

类比的问题在于，当你听到类比时，往往会让你的大脑 “关机”。有些人可能会说，软件架构 “就像 ”建筑架构。不，事实并非如此，可以说，这个听起来不错的类比造成了很多伤害。与此相关的是，软件集装箱化常常被说成是提供了 “就像 ”集装箱运输货物一样移动软件的能力。其实不然。至少可以这么说，但这种类比失去了很多细节。

海运集装箱和软件集装箱确实有很多共同之处。海运集装箱具有标准的形状和尺寸，可以实现强大的规模经济和标准化。软件集装箱也有望带来许多同样的好处。但是，这只是表面上的类比--目标而非事实。

要真正理解容器在软件世界中的意义，我们需要了解容器的制作过程。这就是本文要解释的内容。在这个过程中，我们将讨论容器与容器化、Linux 容器（包括命名空间、cgroups 和分层文件系统），然后通过一些代码从头开始构建一个简单的容器，最后谈谈这一切到底意味着什么。

## 什么是容器？

对于一个词来说，这意味着很多东西！容器 "这个词已经开始用于很多概念（有时是重叠的）。它被用于容器化的类比，也被用于实现容器化的技术。如果我们把它们分开来考虑，就会有更清晰的认识。因此，让我们先谈谈为什么要使用容器，再谈谈如何使用容器。（然后我们再来谈谈为什么）。

但是，run.sh 有依赖性。它需要主机上存在某些库。而且远程运行和本地运行的效果也不尽相同。（如果你听过这首歌，请不要打断我）。于是，我们发明了 AMI（亚马逊机器映像）、VMDK（VMware 映像）和 Vagrantfiles 等等，一切都很顺利。

嗯，算是不错吧。捆绑包很大，很难有效地将它们运送到各地，因为它们不是非常标准化。于是，我们发明了缓存。

![](images/image-12.png)

一切都很顺利。

缓存让 Docker 镜像比 vmdks 或 vagrantfiles 更有效。它让我们可以通过一些通用的基础镜像来运输 deltas，而不是把整个镜像搬来搬去。这意味着我们有能力将整个环境从一个地方运到另一个地方。这就是为什么当你 “docker run whatever ”时，它几乎会立即启动，即使 whatever 描述的是整个操作系统镜像。我们将在（第 N 节）更详细地讨论它是如何工作的。

实际上，这就是容器的意义所在。容器就是要将依赖关系捆绑起来，这样我们就能以可重复、安全的方式发送代码。但这只是一个高层次的目标，而不是定义。所以，让我们来谈谈现实。

## 构件容器

那么（这次是真的！）什么是容器？如果创建一个容器就像系统调用 create_container 一样简单就好了。但事实并非如此。不过老实说，也差不多。

要在底层讨论容器，我们必须先讨论三件事。它们是命名空间、cgroups 和分层文件系统。还有其他一些东西，但这三样构成了其中大部分的奥妙。

### 命名空间

命名空间提供了在一台机器上运行多个容器所需的隔离功能，同时让每个容器看起来都有自己的环境。在编写本报告时，共有六个命名空间。每个命名空间都可以独立请求，相当于为进程（及其子进程）提供了机器资源子集的视图。

这些命名空间是：

* PID：pid 命名空间为进程及其子进程提供了系统中进程子集的视图。把它想象成一个映射表。当 pid 命名空间中的进程向内核请求进程列表时，内核会在映射表中查找。如果进程存在于映射表中，映射 ID 就会被使用，而不是真实 ID。如果进程不存在于映射表中，内核就会假装它根本不存在。pid 命名空间会将在其中创建的第一个进程设为 pid 1（通过将其主机 ID 映射为 1），从而在容器中形成一个孤立的进程树。
* MNT：从某种意义上说，这是最重要的。挂载命名空间为其中的进程提供了自己的挂载表。这意味着它们可以挂载和卸载目录，而不会影响其他命名空间（包括主机命名空间）。更重要的是，结合 pivot_root 系统调用（我们将看到），它允许进程拥有自己的文件系统。这样，我们就能通过交换容器看到的文件系统，让进程以为自己运行在 ubuntu、busybox 或 alpine 上。
* 
