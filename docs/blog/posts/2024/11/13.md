---
date: 2024-11-13
authors:
  - cloaks
# categories:
#   - é«˜çº§æ¶æ„å¸ˆ
tags:
  - ç¿»è¯‘
draft: false
description: BitTorrent æ˜¯ä¸€ä¸ªé€šè¿‡ç½‘ç»œä¸‹è½½å’Œåˆ†å‘æ–‡ä»¶çš„åè®®ã€‚ä¸ä¼ ç»Ÿçš„å®¢æˆ·ç«¯/æœåŠ¡å™¨å…³ç³»ç›¸æ¯”ï¼Œä¸‹è½½è€…è¿æ¥åˆ°ä¸­å¤®æœåŠ¡å™¨ï¼ˆä¾‹å¦‚ï¼šåœ¨ Netflix ä¸Šè§‚çœ‹ç”µå½±ï¼Œæˆ–åŠ è½½æ‚¨æ­£åœ¨é˜…è¯»çš„ç½‘é¡µï¼‰ï¼ŒBitTorrent ç½‘ç»œä¸­çš„å‚ä¸è€…ï¼ˆç§°ä¸ºå¯¹ç­‰ç‚¹ï¼‰ä¸‹è½½å½¼æ­¤ä¹‹é—´çš„æ–‡ä»¶ç‰‡æ®µâ€”â€”è¿™å°±æ˜¯å®ƒæˆä¸ºç‚¹å¯¹ç‚¹åè®®çš„åŸå› ã€‚æˆ‘ä»¬å°†ç ”ç©¶å…¶å·¥ä½œåŸç†ï¼Œå¹¶æ„å»ºæˆ‘ä»¬è‡ªå·±çš„å®¢æˆ·ç«¯ï¼Œè¯¥å®¢æˆ·ç«¯å¯ä»¥æ‰¾åˆ°åŒè¡Œå¹¶åœ¨å®ƒä»¬ä¹‹é—´äº¤æ¢æ•°æ®ã€‚
---

# ä½¿ç”¨ Go å®ç° BitTorrent å®¢æˆ·ç«¯

> åŸæ–‡åœ°å€ï¼š[https://blog.jse.li/posts/torrent/](https://blog.jse.li/posts/torrent/)

BitTorrent æ˜¯ä¸€ä¸ªé€šè¿‡ç½‘ç»œä¸‹è½½å’Œåˆ†å‘æ–‡ä»¶çš„åè®®ã€‚ä¸ä¼ ç»Ÿçš„å®¢æˆ·ç«¯/æœåŠ¡å™¨å…³ç³»ç›¸æ¯”ï¼Œä¸‹è½½è€…è¿æ¥åˆ°ä¸­å¤®æœåŠ¡å™¨ï¼ˆä¾‹å¦‚ï¼šåœ¨ Netflix ä¸Šè§‚çœ‹ç”µå½±ï¼Œæˆ–åŠ è½½æ‚¨æ­£åœ¨é˜…è¯»çš„ç½‘é¡µï¼‰ï¼ŒBitTorrent ç½‘ç»œä¸­çš„å‚ä¸è€…ï¼ˆç§°ä¸ºå¯¹ç­‰ç‚¹ï¼‰ä¸‹è½½å½¼æ­¤ä¹‹é—´çš„æ–‡ä»¶ç‰‡æ®µâ€”â€”è¿™å°±æ˜¯å®ƒæˆä¸ºç‚¹å¯¹ç‚¹åè®®çš„åŸå› ã€‚æˆ‘ä»¬å°†ç ”ç©¶å…¶å·¥ä½œåŸç†ï¼Œå¹¶æ„å»ºæˆ‘ä»¬è‡ªå·±çš„å®¢æˆ·ç«¯ï¼Œè¯¥å®¢æˆ·ç«¯å¯ä»¥æ‰¾åˆ°åŒè¡Œå¹¶åœ¨å®ƒä»¬ä¹‹é—´äº¤æ¢æ•°æ®ã€‚

![](images/image.png)

<!-- more -->

## å¯»æ‰¾å¯¹ç­‰ç½‘ç»œ

è¿™é‡Œæœ‰ä¸€ä¸ªé—®é¢˜ï¼šæˆ‘ä»¬æƒ³ç”¨ BitTorrent ä¸‹è½½ä¸€ä¸ªæ–‡ä»¶ï¼Œä½†å®ƒæ˜¯ä¸€ä¸ªç‚¹å¯¹ç‚¹åè®®ï¼Œæˆ‘ä»¬ä¸çŸ¥é“åœ¨å“ªé‡Œå¯ä»¥æ‰¾åˆ°å¯¹ç­‰ç‚¹æ¥ä¸‹è½½å®ƒã€‚è¿™å¾ˆåƒæ¬åˆ°ä¸€ä¸ªæ–°åŸå¸‚å¹¶è¯•å›¾ç»“äº¤æœ‹å‹â€”â€”ä¹Ÿè®¸æˆ‘ä»¬ä¼šå»å½“åœ°çš„é…’å§æˆ–èšä¼šå°ç»„ï¼

åƒè¿™æ ·çš„é›†ä¸­ä½ç½®æ˜¯è·Ÿè¸ªå™¨èƒŒåçš„é‡è¦ç†å¿µï¼Œè·Ÿè¸ªå™¨æ˜¯ç›¸äº’ä»‹ç»å¯¹ç­‰ç‚¹çš„ä¸­å¤®æœåŠ¡å™¨ã€‚å®ƒä»¬åªæ˜¯é€šè¿‡ HTTP* è¿è¡Œçš„ Web æœåŠ¡å™¨ï¼Œæ‚¨å¯ä»¥åœ¨ http://bttracker.debian.org:6969/ æ‰¾åˆ° Debianã€‚

![](images/image-1.png)

å½“ç„¶ï¼Œå¦‚æœè¿™äº›ä¸­å¤®æœåŠ¡å™¨ä¿ƒè¿›åŒè¡Œäº¤æ¢éæ³•å†…å®¹ï¼Œå®ƒä»¬å¾ˆå¯èƒ½ä¼šå—åˆ°è”é‚¦æ”¿åºœçš„è¢­å‡»ã€‚æ‚¨å¯èƒ½è¿˜è®°å¾—è¯»è¿‡æœ‰å…³ TorrentSpyã€Popcorn Time å’Œ KickassTorrents ç­‰è·Ÿè¸ªå™¨è¢«æŸ¥å°å’Œå…³é—­çš„ä¿¡æ¯ã€‚æ–°æ–¹æ³•é€šè¿‡ä½¿å¯¹ç­‰å‘ç°æˆä¸ºä¸€ä¸ªåˆ†å¸ƒå¼è¿‡ç¨‹æ¥æ¶ˆé™¤ä¸­é—´äººã€‚æˆ‘ä»¬ä¸ä¼šå®æ–½å®ƒä»¬ï¼Œä½†å¦‚æœæ‚¨æœ‰å…´è¶£ï¼Œæ‚¨å¯ä»¥ç ”ç©¶ä¸€äº›æœ¯è¯­ï¼ŒåŒ…æ‹¬ DHTã€PEX å’Œç£åŠ›é“¾æ¥ã€‚

### è§£æ .torrent æ–‡ä»¶

.torrent æ–‡ä»¶æè¿°äº† torrent æ–‡ä»¶çš„å†…å®¹ä»¥åŠç”¨äºè¿æ¥åˆ°è·Ÿè¸ªå™¨çš„ä¿¡æ¯ã€‚è¿™å°±æ˜¯æˆ‘ä»¬å¯åŠ¨ torrent ä¸‹è½½è¿‡ç¨‹æ‰€éœ€è¦çš„ä¸€åˆ‡ã€‚ Debian çš„ .torrent æ–‡ä»¶å¦‚ä¸‹æ‰€ç¤ºï¼š

``` plain
d8:announce41:http://bttracker.debian.org:6969/announce7:comment35:"Debian CD from cdimage.debian.org"13:creation datei1573903810e9:httpseedsl145:https://cdimage.debian.org/cdimage/release/10.2.0//srv/cdbuilder.debian.org/dst/deb-cd/weekly-builds/amd64/iso-cd/debian-10.2.0-amd64-netinst.iso145:https://cdimage.debian.org/cdimage/archive/10.2.0//srv/cdbuilder.debian.org/dst/deb-cd/weekly-builds/amd64/iso-cd/debian-10.2.0-amd64-netinst.isoe4:infod6:lengthi351272960e4:name31:debian-10.2.0-amd64-netinst.iso12:piece lengthi262144e6:pieces26800:ï¿½ï¿½ï¿½ï¿½ï¿½PSï¿½^ï¿½ï¿½ (binary blob of the hashes of each piece)ee
```

è¿™äº›æ··ä¹±çš„å†…å®¹ä»¥ä¸€ç§åä¸º Bencodeï¼ˆå‘éŸ³ä¸º bee-encodeï¼‰çš„æ ¼å¼è¿›è¡Œç¼–ç ï¼Œæˆ‘ä»¬éœ€è¦å¯¹å…¶è¿›è¡Œè§£ç ã€‚

Bencode å¯ä»¥ç¼–ç ä¸ JSON å¤§è‡´ç›¸åŒç±»å‹çš„ç»“æ„ï¼šå­—ç¬¦ä¸²ã€æ•´æ•°ã€åˆ—è¡¨å’Œå­—å…¸ã€‚ Bencoded æ•°æ®ä¸åƒ JSON é‚£æ ·äººç±»å¯è¯»/å¯å†™ï¼Œä½†å®ƒå¯ä»¥æœ‰æ•ˆåœ°å¤„ç†äºŒè¿›åˆ¶æ•°æ®ï¼Œå¹¶ä¸”ä»æµä¸­è§£æéå¸¸ç®€å•ã€‚å­—ç¬¦ä¸²å¸¦æœ‰é•¿åº¦å‰ç¼€ï¼Œçœ‹èµ·æ¥åƒ 4:spamã€‚æ•´æ•°ä½äºå¼€å§‹æ ‡è®°å’Œç»“æŸæ ‡è®°ä¹‹é—´ï¼Œå› æ­¤ 7 å°†ç¼–ç ä¸º i7eã€‚åˆ—è¡¨å’Œå­—å…¸çš„å·¥ä½œæ–¹å¼ç±»ä¼¼ï¼šl4:spami7ee è¡¨ç¤º ['spam', 7]ï¼Œè€Œ d4:spami7ee è¡¨ç¤º {spam: 7}ã€‚

åœ¨æ›´æ¼‚äº®çš„æ ¼å¼ä¸­ï¼Œæˆ‘ä»¬çš„ .torrent æ–‡ä»¶å¦‚ä¸‹æ‰€ç¤ºï¼š

```plain
d
  8:announce
    41:http://bttracker.debian.org:6969/announce
  7:comment
    35:"Debian CD from cdimage.debian.org"
  13:creation date
    i1573903810e
  4:info
    d
      6:length
        i351272960e
      4:name
        31:debian-10.2.0-amd64-netinst.iso
      12:piece length
        i262144e
      6:pieces
        26800:ï¿½ï¿½ï¿½ï¿½ï¿½PSï¿½^ï¿½ï¿½ (binary blob of the hashes of each piece)
    e
e
```

åœ¨è¿™ä¸ªæ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°è·Ÿè¸ªå™¨çš„ URLã€åˆ›å»ºæ—¥æœŸï¼ˆä½œä¸º Unix æ—¶é—´æˆ³ï¼‰ã€æ–‡ä»¶çš„åç§°å’Œå¤§å°ï¼Œä»¥åŠåŒ…å«æ¯ä¸ªç‰‡æ®µçš„ SHA-1 å“ˆå¸Œå€¼çš„å¤§äºŒè¿›åˆ¶ blobï¼Œå®ƒä»¬åŒæ ·æ˜¯ï¼šæˆ‘ä»¬è¦ä¸‹è½½çš„æ–‡ä»¶çš„å¤§å°éƒ¨åˆ†ã€‚æ¯ä¸ªç§å­æ–‡ä»¶çš„ç¡®åˆ‡å¤§å°å„ä¸ç›¸åŒï¼Œä½†é€šå¸¸åœ¨ 256KB åˆ° 1MB ä¹‹é—´ã€‚è¿™æ„å‘³ç€ä¸€ä¸ªå¤§æ–‡ä»¶å¯èƒ½ç”±æ•°åƒä¸ªéƒ¨åˆ†ç»„æˆã€‚æˆ‘ä»¬å°†ä»åŒè¡Œé‚£é‡Œä¸‹è½½è¿™äº›ç‰‡æ®µï¼Œæ ¹æ®æˆ‘ä»¬çš„ torrent æ–‡ä»¶ä¸­çš„å“ˆå¸Œå€¼æ£€æŸ¥å®ƒä»¬ï¼Œå°†å®ƒä»¬ç»„è£…åœ¨ä¸€èµ·ï¼Œç„¶åï¼Œæˆ‘ä»¬å°±å¾—åˆ°äº†ä¸€ä¸ªæ–‡ä»¶ï¼

![](images/image-2.png)

è¿™ç§æœºåˆ¶ä½¿æˆ‘ä»¬èƒ½å¤Ÿåœ¨è¿›è¡Œè¿‡ç¨‹ä¸­éªŒè¯æ¯ä¸ªéƒ¨åˆ†çš„å®Œæ•´æ€§ã€‚å®ƒä½¿ BitTorrent èƒ½å¤ŸæŠµå¾¡æ„å¤–æŸåæˆ–æ•…æ„ torrent ä¸­æ¯’ã€‚é™¤éæ”»å‡»è€…èƒ½å¤Ÿé€šè¿‡åŸåƒæ”»å‡»ç ´å SHA-1ï¼Œå¦åˆ™æˆ‘ä»¬å°†å‡†ç¡®è·å¾—æˆ‘ä»¬æ‰€è¦æ±‚çš„å†…å®¹ã€‚

ç¼–å†™ä¸€ä¸ª Bencode è§£æå™¨çœŸçš„å¾ˆæœ‰è¶£ï¼Œä½†è§£æä¸æ˜¯æˆ‘ä»¬ä»Šå¤©çš„é‡ç‚¹ã€‚ä½†æˆ‘å‘ç° Fredrik Lundh çš„ 50 è¡Œè§£æå™¨ç‰¹åˆ«å…·æœ‰å¯å‘æ€§ã€‚å¯¹äºè¿™ä¸ªé¡¹ç›®ï¼Œæˆ‘ä½¿ç”¨äº† github.com/jackpal/bencode-goï¼š

```go title="bencode.go"
import (
    "github.com/jackpal/bencode-go"
)

type bencodeInfo struct {
    Pieces      string `bencode:"pieces"`
    PieceLength int    `bencode:"piece length"`
    Length      int    `bencode:"length"`
    Name        string `bencode:"name"`
}

type bencodeTorrent struct {
    Announce string      `bencode:"announce"`
    Info     bencodeInfo `bencode:"info"`
}

// Open parses a torrent file
func Open(r io.Reader) (*bencodeTorrent, error) {
    bto := bencodeTorrent{}
    err := bencode.Unmarshal(r, &bto)
    if err != nil {
        return nil, err
    }
    return &bto, nil
}
```

å› ä¸ºæˆ‘å–œæ¬¢ä¿æŒç»“æ„ç›¸å¯¹å¹³å¦ï¼Œå¹¶ä¸”å–œæ¬¢å°†åº”ç”¨ç¨‹åºç»“æ„ä¸åºåˆ—åŒ–ç»“æ„åˆ†å¼€ï¼Œæ‰€ä»¥æˆ‘å¯¼å‡ºäº†ä¸€ä¸ªä¸åŒçš„ã€æ›´å¹³å¦çš„ç»“æ„ï¼Œåä¸º TorrentFileï¼Œå¹¶ç¼–å†™äº†ä¸€äº›è¾…åŠ©å‡½æ•°æ¥åœ¨ä¸¤è€…ä¹‹é—´è¿›è¡Œè½¬æ¢ã€‚

å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œæˆ‘å°†ç‰‡æ®µï¼ˆä»¥å‰æ˜¯å­—ç¬¦ä¸²ï¼‰åˆ†å‰²æˆå“ˆå¸Œå€¼ç‰‡æ®µï¼ˆæ¯ä¸ª [20] å­—èŠ‚ï¼‰ï¼Œä»¥ä¾¿ç¨åå¯ä»¥è½»æ¾è®¿é—®å„ä¸ªå“ˆå¸Œå€¼ã€‚æˆ‘è¿˜è®¡ç®—äº†æ•´ä¸ªç¼–ç ä¿¡æ¯å­—å…¸ï¼ˆåŒ…å«åç§°ã€å¤§å°å’Œç‰‡æ®µå“ˆå¸Œå€¼çš„å­—å…¸ï¼‰çš„ SHA-1 å“ˆå¸Œå€¼ã€‚æˆ‘ä»¬å°†å…¶ç§°ä¸º infohashï¼Œå½“æˆ‘ä»¬ä¸è·Ÿè¸ªå™¨å’Œå¯¹ç­‰ç‚¹å¯¹è¯æ—¶ï¼Œå®ƒå”¯ä¸€åœ°æ ‡è¯†æ–‡ä»¶ã€‚ç¨åä¼šè¯¦ç»†ä»‹ç»è¿™ä¸€ç‚¹ã€‚

![](images/image-3.png)

```go
type TorrentFile struct {
    Announce    string
    InfoHash    [20]byte
    PieceHashes [][20]byte
    PieceLength int
    Length      int
    Name        string
}

func (bto bencodeTorrent) toTorrentFile() (TorrentFile, error) {
// â€¦
}
```

### ä»è·Ÿè¸ªå™¨æ£€ç´¢å¯¹ç­‰ç‚¹

ç°åœ¨æˆ‘ä»¬æœ‰äº†æœ‰å…³æ–‡ä»¶åŠå…¶è·Ÿè¸ªå™¨çš„ä¿¡æ¯ï¼Œè®©æˆ‘ä»¬ä¸è·Ÿè¸ªå™¨äº¤è°ˆä»¥å®£å¸ƒæˆ‘ä»¬ä½œä¸ºå¯¹ç­‰ç‚¹çš„å­˜åœ¨å¹¶æ£€ç´¢å…¶ä»–å¯¹ç­‰ç‚¹çš„åˆ—è¡¨ã€‚æˆ‘ä»¬åªéœ€è¦å‘ .torrent æ–‡ä»¶ä¸­æä¾›çš„å…¬å‘Š URL å‘å‡º GET è¯·æ±‚ï¼Œå¹¶å¸¦æœ‰ä¸€äº›æŸ¥è¯¢å‚æ•°ï¼š

```go
func (t *TorrentFile) buildTrackerURL(peerID [20]byte, port uint16) (string, error) {
    base, err := url.Parse(t.Announce)
    if err != nil {
        return "", err
    }
    params := url.Values{
        "info_hash":  []string{string(t.InfoHash[:])},
        "peer_id":    []string{string(peerID[:])},
        "port":       []string{strconv.Itoa(int(Port))},
        "uploaded":   []string{"0"},
        "downloaded": []string{"0"},
        "compact":    []string{"1"},
        "left":       []string{strconv.Itoa(t.Length)},
    }
    base.RawQuery = params.Encode()
    return base.String(), nil
}
```

é‡è¦çš„ï¼š

* info_hashï¼šæ ‡è¯†æˆ‘ä»¬å°è¯•ä¸‹è½½çš„æ–‡ä»¶ã€‚è¿™æ˜¯æˆ‘ä»¬ä¹‹å‰æ ¹æ®ç¼–ç åçš„ä¿¡æ¯å­—å…¸è®¡ç®—å‡ºçš„ä¿¡æ¯å“ˆå¸Œå€¼ã€‚è·Ÿè¸ªå™¨å°†ä½¿ç”¨å®ƒæ¥ç¡®å®šè¦å‘æˆ‘ä»¬å±•ç¤ºå“ªäº›å¯¹ç­‰ç‚¹ã€‚

* peer_idï¼šä¸€ä¸ª 20 å­—èŠ‚çš„åç§°ï¼Œç”¨äºå‘è·Ÿè¸ªå™¨å’Œå¯¹ç­‰ç‚¹æ ‡è¯†æˆ‘ä»¬è‡ªå·±ã€‚æˆ‘ä»¬å°†ä¸ºæ­¤ç”Ÿæˆ 20 ä¸ªéšæœºå­—èŠ‚ã€‚çœŸæ­£çš„ BitTorrent å®¢æˆ·ç«¯å…·æœ‰ç±»ä¼¼ -TR2940-k8hj0wgej6ch çš„ IDï¼Œç”¨äºæ ‡è¯†å®¢æˆ·ç«¯è½¯ä»¶å’Œç‰ˆæœ¬ - åœ¨æœ¬ä¾‹ä¸­ï¼ŒTR2940 ä»£è¡¨ Transmission å®¢æˆ·ç«¯ 2.94ã€‚

![](images/image-4.png)

### è§£æè·Ÿè¸ªå™¨å“åº”

æˆ‘ä»¬æ”¶åˆ°ä¸€ä¸ªç¼–ç å“åº”ï¼š

```plain
d
  8:interval
    i900e
  5:peers
    252:(another long binary blob)
e
```

Interval å‘Šè¯‰æˆ‘ä»¬åº”è¯¥å¤šä¹…å†æ¬¡è¿æ¥åˆ°è·Ÿè¸ªå™¨ä»¥åˆ·æ–°æˆ‘ä»¬çš„å¯¹ç­‰ç‚¹åˆ—è¡¨ã€‚å€¼ 900 æ„å‘³ç€æˆ‘ä»¬åº”è¯¥æ¯ 15 åˆ†é’Ÿï¼ˆ900 ç§’ï¼‰é‡æ–°è¿æ¥ä¸€æ¬¡ã€‚

Peers æ˜¯å¦ä¸€ä¸ªé•¿äºŒè¿›åˆ¶ blobï¼ŒåŒ…å«æ¯ä¸ªå¯¹ç­‰ç‚¹çš„ IP åœ°å€ã€‚å®ƒç”±å…­ä¸ªå­—èŠ‚ç»„æˆã€‚æ¯ç»„ä¸­çš„å‰å››ä¸ªå­—èŠ‚ä»£è¡¨å¯¹ç­‰æ–¹çš„ IP åœ°å€ï¼Œæ¯ä¸ªå­—èŠ‚ä»£è¡¨ IP ä¸­çš„ä¸€ä¸ªæ•°å­—ã€‚æœ€åä¸¤ä¸ªå­—èŠ‚è¡¨ç¤ºç«¯å£ï¼Œä¸º big-endian uint16ã€‚ Big-endianï¼ˆæˆ–ç½‘ç»œé¡ºåºï¼‰æ„å‘³ç€æˆ‘ä»¬å¯ä»¥é€šè¿‡å°†ä¸€ç»„å­—èŠ‚ä»å·¦åˆ°å³å‹ç¼©åœ¨ä¸€èµ·æ¥å°†å®ƒä»¬è§£é‡Šä¸ºæ•´æ•°ã€‚ä¾‹å¦‚ï¼Œå­—èŠ‚ 0x1Aã€0xE1 æ„æˆåè¿›åˆ¶çš„ 0x1AE1 æˆ– 6881ã€‚*

![](images/image-5.png)

```go
// Peer encodes connection information for a peer
type Peer struct {
    IP   net.IP
    Port uint16
}

// Unmarshal parses peer IP addresses and ports from a buffer
func Unmarshal(peersBin []byte) ([]Peer, error) {
    const peerSize = 6 // 4 for IP, 2 for port
    numPeers := len(peersBin) / peerSize
    if len(peersBin)%peerSize != 0 {
        err := fmt.Errorf("Received malformed peers")
        return nil, err
    }
    peers := make([]Peer, numPeers)
    for i := 0; i < numPeers; i++ {
        offset := i * peerSize
        peers[i].IP = net.IP(peersBin[offset : offset+4])
        peers[i].Port = binary.BigEndian.Uint16(peersBin[offset+4 : offset+6])
    }
    return peers, nil
}
```

## ä»å¯¹ç­‰ç½‘ç»œä¸­ä¸‹è½½

ç°åœ¨æˆ‘ä»¬æœ‰äº†ä¸€ä¸ªåŒè¡Œåˆ—è¡¨ï¼Œæ˜¯æ—¶å€™ä¸ä»–ä»¬è”ç³»å¹¶å¼€å§‹ä¸‹è½½ä½œå“äº†ï¼æˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªè¿‡ç¨‹åˆ†è§£ä¸ºå‡ ä¸ªæ­¥éª¤ã€‚å¯¹äºæ¯ä¸ªåŒè¡Œï¼Œæˆ‘ä»¬å¸Œæœ›ï¼š

1. å¯åŠ¨ä¸å¯¹ç­‰æ–¹çš„ TCP è¿æ¥ã€‚è¿™å°±åƒæ‹¨æ‰“ç”µè¯ä¸€æ ·ã€‚
2. å®ŒæˆåŒå‘ BitTorrent æ¡æ‰‹ã€‚ â€œä½ å¥½ï¼Ÿâ€ â€œä½ å¥½ã€‚â€
3. äº¤æ¢æ¶ˆæ¯ä»¥ä¸‹è½½ç‰‡æ®µã€‚ â€œæˆ‘æƒ³è¦ç¬¬ 231 å·ä½œå“ã€‚â€

### å»ºç«‹ TCP è¿æ¥

```go
conn, err := net.DialTimeout("tcp", peer.String(), 3*time.Second)
if err != nil {
    return nil, err
}
```

æˆ‘è®¾ç½®äº†ä¸€ä¸ªè¶…æ—¶ï¼Œè¿™æ ·æˆ‘å°±ä¸ä¼šåœ¨ä¸å…è®¸æˆ‘è¿æ¥çš„åŒä¼´èº«ä¸Šæµªè´¹å¤ªå¤šæ—¶é—´ã€‚åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œè¿™æ˜¯ä¸€ä¸ªéå¸¸æ ‡å‡†çš„ TCP è¿æ¥ã€‚

### å®Œæˆæ¡æ‰‹

æˆ‘ä»¬åˆšåˆšä¸å¯¹ç­‰æ–¹å»ºç«‹äº†è¿æ¥ï¼Œä½†æˆ‘ä»¬æƒ³è¦æ¡æ‰‹æ¥éªŒè¯æˆ‘ä»¬å¯¹å¯¹ç­‰æ–¹çš„å‡è®¾

1. å¯ä»¥ä½¿ç”¨ BitTorrent åè®®è¿›è¡Œé€šä¿¡
2. èƒ½å¤Ÿç†è§£å¹¶å›å¤æˆ‘ä»¬çš„æ¶ˆæ¯
3. æœ‰æˆ‘ä»¬æƒ³è¦çš„æ–‡ä»¶ï¼Œæˆ–è€…è‡³å°‘çŸ¥é“æˆ‘ä»¬åœ¨è¯´ä»€ä¹ˆ

![](images/image-6.png)

æˆ‘çˆ¶äº²å‘Šè¯‰æˆ‘ï¼Œè‰¯å¥½æ¡æ‰‹çš„ç§˜è¯€æ˜¯æ¡ç´§å’Œç›®å…‰æ¥è§¦ã€‚è‰¯å¥½çš„ BitTorrent æ¡æ‰‹çš„ç§˜è¯€åœ¨äºå®ƒç”±äº”ä¸ªéƒ¨åˆ†ç»„æˆï¼š

1. åè®®æ ‡è¯†ç¬¦çš„é•¿åº¦ï¼Œå§‹ç»ˆä¸º 19ï¼ˆåå…­è¿›åˆ¶ä¸º 0x13ï¼‰
2. åè®®æ ‡è¯†ç¬¦ï¼Œç§°ä¸º pstrï¼Œå§‹ç»ˆæ˜¯ BitTorrent åè®®
3. å…«ä¸ªä¿ç•™å­—èŠ‚ï¼Œå…¨éƒ¨è®¾ç½®ä¸º 0ã€‚æˆ‘ä»¬å°†å…¶ä¸­ä¸€äº›ç¿»è½¬ä¸º 1ï¼Œä»¥è¡¨æ˜æˆ‘ä»¬æ”¯æŒæŸäº›æ‰©å±•ã€‚ä½†æˆ‘ä»¬ä¸è¿™æ ·åšï¼Œæ‰€ä»¥æˆ‘ä»¬å°†å®ƒä»¬ä¿æŒä¸º 0ã€‚
4. æˆ‘ä»¬ä¹‹å‰è®¡ç®—çš„ infohash ç”¨äºè¯†åˆ«æˆ‘ä»¬æƒ³è¦çš„æ–‡ä»¶
5. æˆ‘ä»¬ç¼–å†™çš„ç”¨äºè¯†åˆ«è‡ªå·±èº«ä»½çš„ Peer ID

æ”¾åœ¨ä¸€èµ·ï¼Œæ¡æ‰‹å­—ç¬¦ä¸²å¯èƒ½å¦‚ä¸‹æ‰€ç¤ºï¼š

```bash
\x13BitTorrent protocol\x00\x00\x00\x00\x00\x00\x00\x00\x86\xd4\xc8\x00\x24\xa4\x69\xbe\x4c\x50\xbc\x5a\x10\x2c\xf7\x17\x80\x31\x00\x74-TR2940-k8hj0wgej6ch
```

åœ¨æˆ‘ä»¬å‘å¯¹ç­‰æ–¹å‘é€æ¡æ‰‹ä¿¡å·åï¼Œæˆ‘ä»¬åº”è¯¥æ”¶åˆ°ä»¥ç›¸åŒæ ¼å¼è¿”å›çš„æ¡æ‰‹ä¿¡å·ã€‚æˆ‘ä»¬è¿”å›çš„ä¿¡æ¯å“ˆå¸Œå€¼åº”è¯¥ä¸æˆ‘ä»¬å‘é€çš„ä¿¡æ¯å“ˆå¸Œå€¼ç›¸åŒ¹é…ï¼Œè¿™æ ·æˆ‘ä»¬å°±çŸ¥é“æˆ‘ä»¬æ­£åœ¨è°ˆè®ºåŒä¸€ä¸ªæ–‡ä»¶ã€‚å¦‚æœä¸€åˆ‡æŒ‰è®¡åˆ’è¿›è¡Œï¼Œæˆ‘ä»¬å°±å¯ä»¥å‡ºå‘äº†ã€‚å¦‚æœæ²¡æœ‰ï¼Œæˆ‘ä»¬å¯ä»¥åˆ‡æ–­è¿æ¥ï¼Œå› ä¸ºå‡ºç°äº†é—®é¢˜ã€‚ â€œä½ å¥½ï¼Ÿâ€ â€œè¿™æ˜¯è°ï¼Ÿä½ æƒ³è¦ä»€ä¹ˆï¼Ÿâ€â€œå¥½å§ï¼Œå“‡ï¼Œå·ç æ‰“é”™äº†ã€‚â€

åœ¨æˆ‘ä»¬çš„ä»£ç ä¸­ï¼Œè®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªç»“æ„ä½“æ¥è¡¨ç¤ºæ¡æ‰‹ï¼Œå¹¶ç¼–å†™ä¸€äº›ç”¨äºåºåˆ—åŒ–å’Œè¯»å–å®ƒä»¬çš„æ–¹æ³•ï¼š

```go
// A Handshake is a special message that a peer uses to identify itself
type Handshake struct {
    Pstr     string
    InfoHash [20]byte
    PeerID   [20]byte
}

// Serialize serializes the handshake to a buffer
func (h *Handshake) Serialize() []byte {
    buf := make([]byte, len(h.Pstr)+49)
    buf[0] = byte(len(h.Pstr))
    curr := 1
    curr += copy(buf[curr:], h.Pstr)
    curr += copy(buf[curr:], make([]byte, 8)) // 8 reserved bytes
    curr += copy(buf[curr:], h.InfoHash[:])
    curr += copy(buf[curr:], h.PeerID[:])
    return buf
}

// Read parses a handshake from a stream
func Read(r io.Reader) (*Handshake, error) {
    // Do Serialize(), but backwards
    // ...
}
```

### å‘é€å’Œæ¥æ”¶æ¶ˆæ¯

å®Œæˆåˆå§‹æ¡æ‰‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥å‘é€å’Œæ¥æ”¶æ¶ˆæ¯ã€‚å¥½å§ï¼Œä¸å®Œå…¨æ˜¯â€”â€”å¦‚æœå¦ä¸€ä¸ªå¯¹ç­‰æ–¹è¿˜æ²¡æœ‰å‡†å¤‡å¥½æ¥å—æ¶ˆæ¯ï¼Œæˆ‘ä»¬å°±æ— æ³•å‘é€ä»»ä½•æ¶ˆæ¯ï¼Œç›´åˆ°ä»–ä»¬å‘Šè¯‰æˆ‘ä»¬ä»–ä»¬å‡†å¤‡å¥½äº†ã€‚åœ¨è¿™ç§çŠ¶æ€ä¸‹ï¼Œæˆ‘ä»¬è¢«è®¤ä¸ºæ˜¯è¢«å¯¹æ–¹çª’æ¯äº†ã€‚ä»–ä»¬ä¼šå‘æˆ‘ä»¬å‘é€ä¸€æ¡ç•…é€šæ— é˜»çš„æ¶ˆæ¯ï¼Œè®©æˆ‘ä»¬çŸ¥é“æˆ‘ä»¬å¯ä»¥å¼€å§‹å‘ä»–ä»¬ç´¢è¦æ•°æ®ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å‡è®¾è‡ªå·±è¢«çª’æ¯äº†ï¼Œç›´åˆ°äº‹å®è¯æ˜å¹¶éå¦‚æ­¤ã€‚

ä¸€æ—¦æˆ‘ä»¬è¢«è§£é™¤é˜»å¡ï¼Œæˆ‘ä»¬å°±å¯ä»¥å¼€å§‹å‘é€å¯¹ç¢ç‰‡çš„è¯·æ±‚ï¼Œä»–ä»¬å¯ä»¥å‘æˆ‘ä»¬å‘é€åŒ…å«ç¢ç‰‡çš„æ¶ˆæ¯ã€‚

![](images/image-7.png)

#### è§£é‡Šæ¶ˆæ¯

æ¶ˆæ¯å…·æœ‰é•¿åº¦ã€ID å’Œæœ‰æ•ˆè´Ÿè½½ã€‚åœ¨ç”µçº¿ä¸Šï¼Œå®ƒçœ‹èµ·æ¥åƒï¼š

![](images/image-8.png)

æ¶ˆæ¯ä»¥é•¿åº¦æŒ‡ç¤ºç¬¦å¼€å¤´ï¼Œå®ƒå‘Šè¯‰æˆ‘ä»¬æ¶ˆæ¯çš„é•¿åº¦ä¸ºå¤šå°‘å­—èŠ‚ã€‚å®ƒæ˜¯ä¸€ä¸ª 32 ä½æ•´æ•°ï¼Œè¿™æ„å‘³ç€å®ƒç”±æŒ‰å¤§ç«¯é¡ºåºæ··åˆåœ¨ä¸€èµ·çš„å››ä¸ªå­—èŠ‚ç»„æˆã€‚ä¸‹ä¸€ä¸ªå­—èŠ‚ï¼Œå³ IDï¼Œå‘Šè¯‰æˆ‘ä»¬æ­£åœ¨æ¥æ”¶å“ªç§ç±»å‹çš„æ¶ˆæ¯ï¼Œä¾‹å¦‚ï¼Œ2 ä¸ªå­—èŠ‚è¡¨ç¤ºâ€œæ„Ÿå…´è¶£â€ã€‚æœ€åï¼Œå¯é€‰çš„æœ‰æ•ˆè´Ÿè½½å¡«å……æ¶ˆæ¯çš„å‰©ä½™é•¿åº¦ã€‚

```go
type messageID uint8

const (
    MsgChoke         messageID = 0
    MsgUnchoke       messageID = 1
    MsgInterested    messageID = 2
    MsgNotInterested messageID = 3
    MsgHave          messageID = 4
    MsgBitfield      messageID = 5
    MsgRequest       messageID = 6
    MsgPiece         messageID = 7
    MsgCancel        messageID = 8
)

// Message stores ID and payload of a message
type Message struct {
    ID      messageID
    Payload []byte
}

// Serialize serializes a message into a buffer of the form
// <length prefix><message ID><payload>
// Interprets `nil` as a keep-alive message
func (m *Message) Serialize() []byte {
    if m == nil {
        return make([]byte, 4)
    }
    length := uint32(len(m.Payload) + 1) // +1 for id
    buf := make([]byte, 4+length)
    binary.BigEndian.PutUint32(buf[0:4], length)
    buf[4] = byte(m.ID)
    copy(buf[5:], m.Payload)
    return buf
}
```

è¦ä»æµä¸­è¯»å–æ¶ˆæ¯ï¼Œæˆ‘ä»¬åªéœ€éµå¾ªæ¶ˆæ¯çš„æ ¼å¼å³å¯ã€‚æˆ‘ä»¬è¯»å–å››ä¸ªå­—èŠ‚å¹¶å°†å®ƒä»¬è§£é‡Šä¸º uint32 ä»¥è·å–æ¶ˆæ¯çš„é•¿åº¦ã€‚ç„¶åï¼Œæˆ‘ä»¬è¯»å–è¯¥å­—èŠ‚æ•°ä»¥è·å– IDï¼ˆç¬¬ä¸€ä¸ªå­—èŠ‚ï¼‰å’Œæœ‰æ•ˆè´Ÿè½½ï¼ˆå‰©ä½™å­—èŠ‚ï¼‰ã€‚

```go
// Read parses a message from a stream. Returns `nil` on keep-alive message
func Read(r io.Reader) (*Message, error) {
    lengthBuf := make([]byte, 4)
    _, err := io.ReadFull(r, lengthBuf)
    if err != nil {
        return nil, err
    }
    length := binary.BigEndian.Uint32(lengthBuf)

    // keep-alive message
    if length == 0 {
        return nil, nil
    }

    messageBuf := make([]byte, length)
    _, err = io.ReadFull(r, messageBuf)
    if err != nil {
        return nil, err
    }

    m := Message{
        ID:      messageID(messageBuf[0]),
        Payload: messageBuf[1:],
    }

    return &m, nil
}
```

#### Bit å­—æ®µ

æ¯”ç‰¹å­—æ®µæ˜¯æœ€æœ‰è¶£çš„ä¿¡æ¯ç±»å‹ä¹‹ä¸€ï¼Œå®ƒæ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼ŒåŒè¡Œå¯ä»¥ç”¨å®ƒæ¥æœ‰æ•ˆåœ°ç¼–ç ä»–ä»¬èƒ½å¤Ÿå‘é€ç»™æˆ‘ä»¬çš„æ£‹å­ã€‚æ¯”ç‰¹å­—æ®µçœ‹èµ·æ¥å°±åƒä¸€ä¸ªå­—èŠ‚æ•°ç»„ï¼Œæˆ‘ä»¬åªéœ€æŸ¥çœ‹è®¾ç½®ä¸º 1 çš„æ¯”ç‰¹çš„ä½ç½®ï¼Œå°±èƒ½çŸ¥é“ä»–ä»¬æœ‰å“ªäº›ä¿¡æ¯ã€‚æˆ‘ä»¬ä»ä¸€å¼ å…¨ä¸º 0 çš„ç©ºç™½å¡å¼€å§‹ï¼Œç„¶åå°†æ¯”ç‰¹ä½ç¿»è½¬ä¸º 1ï¼Œå°†å…¶ä½ç½®æ ‡è®°ä¸º â€œå·²ç›–ç« â€ã€‚

![](images/image-9.png)

é€šè¿‡ä½¿ç”¨æ¯”ç‰¹è€Œä¸æ˜¯å­—èŠ‚ï¼Œè¿™ç§æ•°æ®ç»“æ„è¶…çº§ç´§å‡‘ã€‚æˆ‘ä»¬å¯ä»¥åœ¨ä¸€ä¸ªå­—èŠ‚ï¼ˆä¸€ä¸ª bool çš„å¤§å°ï¼‰çš„ç©ºé—´å†…å¡å…¥å…«ä¸ªç‰‡æ®µçš„ä¿¡æ¯ã€‚ä½†è¿™æ ·åšçš„ä»£ä»·æ˜¯ï¼Œè®¿é—®æ•°å€¼å˜å¾—æœ‰ç‚¹éº»çƒ¦ã€‚è®¡ç®—æœºèƒ½å¯»å€çš„æœ€å°å†…å­˜å•ä½æ˜¯å­—èŠ‚ï¼Œå› æ­¤è¦è®¿é—®æ¯”ç‰¹ï¼Œæˆ‘ä»¬å¿…é¡»è¿›è¡Œä¸€äº›æ¯”ç‰¹æ“ä½œï¼š

```go
// A Bitfield represents the pieces that a peer has
type Bitfield []byte

// HasPiece tells if a bitfield has a particular index set
func (bf Bitfield) HasPiece(index int) bool {
    byteIndex := index / 8
    offset := index % 8
    return bf[byteIndex]>>(7-offset)&1 != 0
}

// SetPiece sets a bit in the bitfield
func (bf Bitfield) SetPiece(index int) {
    byteIndex := index / 8
    offset := index % 8
    bf[byteIndex] |= 1 << (7 - offset)
}
```

### å°†æ‰€æœ‰çš„å†…å®¹æ•´åˆåˆ°ä¸€èµ·

ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»æ‹¥æœ‰äº†ä¸‹è½½æ´ªæµæ‰€éœ€çš„æ‰€æœ‰å·¥å…·ï¼šæˆ‘ä»¬æœ‰äº†ä»è·Ÿè¸ªå™¨è·å–çš„å¯¹ç­‰ç‚¹åˆ—è¡¨ï¼Œå¯ä»¥é€šè¿‡æ‹¨å· TCP è¿æ¥ã€å¯åŠ¨æ¡æ‰‹ä»¥åŠå‘é€å’Œæ¥æ”¶æ¶ˆæ¯ä¸å®ƒä»¬é€šä¿¡ã€‚æˆ‘ä»¬çš„æœ€åä¸€ä¸ªå¤§é—®é¢˜æ˜¯å¤„ç†åŒæ—¶ä¸å¤šä¸ªå¯¹ç­‰ä½“é€šä¿¡æ‰€æ¶‰åŠçš„å¹¶å‘é—®é¢˜ï¼Œä»¥åŠåœ¨ä¸å¯¹ç­‰ä½“äº¤äº’æ—¶ç®¡ç†å¯¹ç­‰ä½“çš„çŠ¶æ€ã€‚è¿™äº›éƒ½æ˜¯ç»å…¸çš„ç¡¬ä»¶é—®é¢˜ã€‚

#### ç®¡ç†å¹¶å‘æ€§ï¼šä½œä¸ºé˜Ÿåˆ—çš„é€šé“

åœ¨ Go ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡é€šä¿¡æ¥å…±äº«å†…å­˜ï¼Œæˆ‘ä»¬å¯ä»¥å°† Go é€šé“è§†ä¸ºå»‰ä»·çš„çº¿ç¨‹å®‰å…¨é˜Ÿåˆ—ã€‚

æˆ‘ä»¬å°†è®¾ç½®ä¸¤ä¸ªé€šé“æ¥åŒæ­¥æˆ‘ä»¬çš„å¹¶å‘å·¥ä½œè€…ï¼šä¸€ä¸ªç”¨äºåœ¨å¯¹ç­‰ç¨‹åºä¹‹é—´åˆ†é…å·¥ä½œï¼ˆä¸‹è½½æ–‡ä»¶ï¼‰ï¼Œå¦ä¸€ä¸ªç”¨äºæ”¶é›†ä¸‹è½½çš„æ–‡ä»¶ã€‚å½“ä¸‹è½½çš„ç‰‡æ®µé€šè¿‡ç»“æœé€šé“è¿›å…¥æ—¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥å°†å®ƒä»¬å¤åˆ¶åˆ°ç¼“å†²åŒºï¼Œå¼€å§‹ç»„è£…æˆ‘ä»¬çš„å®Œæ•´æ–‡ä»¶ã€‚

```go
// Init queues for workers to retrieve work and send results
workQueue := make(chan *pieceWork, len(t.PieceHashes))
results := make(chan *pieceResult)
for index, hash := range t.PieceHashes {
    length := t.calculatePieceSize(index)
    workQueue <- &pieceWork{index, hash, length}
}

// Start workers
for _, peer := range t.Peers {
    go t.startDownloadWorker(peer, workQueue, results)
}

// Collect results into a buffer until full
buf := make([]byte, t.Length)
donePieces := 0
for donePieces < len(t.PieceHashes) {
    res := <-results
    begin, end := t.calculateBoundsForPiece(res.index)
    copy(buf[begin:end], res.buf)
    donePieces++
}
close(workQueue)
```

æˆ‘ä»¬å°†ä¸ºä»è·Ÿè¸ªå™¨æ¥æ”¶åˆ°çš„æ¯ä¸ªå¯¹ç­‰ç‚¹ç”Ÿæˆä¸€ä¸ª Worker goroutineã€‚å®ƒå°†è¿æ¥å¹¶ä¸å¯¹ç­‰ä½“æ¡æ‰‹ï¼Œç„¶åå¼€å§‹ä» workQueue ä¸­æ£€ç´¢å·¥ä½œï¼Œå°è¯•ä¸‹è½½å·¥ä½œï¼Œå¹¶é€šè¿‡ç»“æœé€šé“å‘é€ä¸‹è½½çš„å·¥ä½œã€‚

![](images/image-10.png)

```go
func (t *Torrent) startDownloadWorker(peer peers.Peer, workQueue chan *pieceWork, results chan *pieceResult) {
    c, err := client.New(peer, t.PeerID, t.InfoHash)
    if err != nil {
        log.Printf("Could not handshake with %s. Disconnecting\n", peer.IP)
        return
    }
    defer c.Conn.Close()
    log.Printf("Completed handshake with %s\n", peer.IP)

    c.SendUnchoke()
    c.SendInterested()

    for pw := range workQueue {
        if !c.Bitfield.HasPiece(pw.index) {
            workQueue <- pw // Put piece back on the queue
            continue
        }

        // Download the piece
        buf, err := attemptDownloadPiece(c, pw)
        if err != nil {
            log.Println("Exiting", err)
            workQueue <- pw // Put piece back on the queue
            return
        }

        err = checkIntegrity(pw, buf)
        if err != nil {
            log.Printf("Piece #%d failed integrity check\n", pw.index)
            workQueue <- pw // Put piece back on the queue
            continue
        }

        c.SendHave(pw.index)
        results <- &pieceResult{pw.index, buf}
    }
}
```

#### ç®¡ç†çŠ¶æ€

æˆ‘ä»¬å°†åœ¨ä¸€ä¸ªç»“æ„ä½“ä¸­è·Ÿè¸ªæ¯ä¸ªå¯¹ç­‰ç‚¹ï¼Œå¹¶åœ¨è¯»å–ä¿¡æ¯æ—¶ä¿®æ”¹è¯¥ç»“æ„ä½“ã€‚å®ƒå°†åŒ…æ‹¬æˆ‘ä»¬ä»å¯¹ç­‰ç‚¹ä¸‹è½½äº†å¤šå°‘ä¿¡æ¯ã€æˆ‘ä»¬å‘å¯¹ç­‰ç‚¹è¯·æ±‚äº†å¤šå°‘ä¿¡æ¯ä»¥åŠæˆ‘ä»¬æ˜¯å¦è¢«ææ–­ç­‰æ•°æ®ã€‚å¦‚æœæˆ‘ä»¬æƒ³è¿›ä¸€æ­¥æ‰©å±•ï¼Œå¯ä»¥å°†å…¶å½¢å¼åŒ–ä¸ºæœ‰é™çŠ¶æ€æœºã€‚ä¸è¿‡ï¼Œç°åœ¨æœ‰ä¸€ä¸ªç»“æ„ä½“å’Œä¸€ä¸ªå¼€å…³å°±è¶³å¤Ÿäº†ã€‚

```go
type pieceProgress struct {
    index      int
    client     *client.Client
    buf        []byte
    downloaded int
    requested  int
    backlog    int
}

func (state *pieceProgress) readMessage() error {
    msg, err := state.client.Read() // this call blocks
    switch msg.ID {
    case message.MsgUnchoke:
        state.client.Choked = false
    case message.MsgChoke:
        state.client.Choked = true
    case message.MsgHave:
        index, err := message.ParseHave(msg)
        state.client.Bitfield.SetPiece(index)
    case message.MsgPiece:
        n, err := message.ParsePiece(state.index, state.buf, msg)
        state.downloaded += n
        state.backlog--
    }
    return nil
}
```

#### Time to make requests!

æ–‡ä»¶ã€ç‰‡æ®µå’Œç‰‡æ®µå“ˆå¸Œå€¼å¹¶ä¸æ˜¯å…¨éƒ¨ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥è¿›ä¸€æ­¥å°†ç‰‡æ®µåˆ†è§£ä¸ºå—ã€‚åŒºå—æ˜¯ç‰‡æ®µçš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å®ƒæ‰€åœ¨ç‰‡æ®µçš„ç´¢å¼•ã€ç‰‡æ®µå†…çš„å­—èŠ‚åç§»é‡å’Œé•¿åº¦æ¥å®Œå…¨å®šä¹‰ä¸€ä¸ªåŒºå—ã€‚å½“æˆ‘ä»¬å‘å¯¹ç­‰ç¨‹åºè¯·æ±‚æ•°æ®æ—¶ï¼Œå®é™…ä¸Šå°±æ˜¯åœ¨è¯·æ±‚æ•°æ®å—ã€‚ä¸€ä¸ªæ•°æ®å—é€šå¸¸æœ‰ 16KB å¤§ï¼Œè¿™æ„å‘³ç€ä¸€ä¸ª 256 KB çš„æ•°æ®å—å®é™…ä¸Šå¯èƒ½éœ€è¦ 16 æ¬¡è¯·æ±‚ã€‚

å¦‚æœå¯¹ç­‰è®¾å¤‡æ”¶åˆ°ä¸€ä¸ªå¤§äº 16KB çš„æ•°æ®å—è¯·æ±‚ï¼Œå®ƒä»¬å°±ä¼šåˆ‡æ–­è¿æ¥ã€‚ä¸è¿‡ï¼Œæ ¹æ®æˆ‘çš„ç»éªŒï¼Œå®ƒä»¬é€šå¸¸å®Œå…¨ä¹æ„æ»¡è¶³æœ€å¤§ 128KB çš„è¯·æ±‚ã€‚æˆ‘åœ¨ä½¿ç”¨æ›´å¤§çš„æ•°æ®å—æ—¶ï¼Œæ€»ä½“é€Ÿåº¦åªå¾—åˆ°äº†é€‚åº¦çš„æå‡ï¼Œå› æ­¤æœ€å¥½è¿˜æ˜¯éµå®ˆè§„èŒƒã€‚

#### æµæ°´çº¿

ç½‘ç»œå¾€è¿”çš„æˆæœ¬å¾ˆé«˜ï¼Œé€ä¸ªè¯·æ±‚æ¯ä¸ªåŒºå—ç»å¯¹ä¼šé™ä½æˆ‘ä»¬çš„ä¸‹è½½æ€§èƒ½ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¿…é¡»å¯¹è¯·æ±‚è¿›è¡Œç®¡é“åŒ–å¤„ç†ï¼Œä»¥ä¿æŒä¸€å®šæ•°é‡çš„æœªå®Œæˆè¯·æ±‚çš„æŒç»­å‹åŠ›ã€‚è¿™å¯ä»¥å°†æˆ‘ä»¬è¿æ¥çš„ååé‡æé«˜ä¸€ä¸ªæ•°é‡çº§ã€‚

![](images/image-11.png)

é€šå¸¸ï¼ŒBitTorrent å®¢æˆ·ç«¯ä¼šä¿ç•™ä¸€ä¸ªåŒ…å«äº”ä¸ªç®¡é“è¯·æ±‚çš„é˜Ÿåˆ—ï¼Œè¿™ä¹Ÿæ˜¯æˆ‘è¦ä½¿ç”¨çš„å€¼ã€‚æˆ‘å‘ç°å¢åŠ é˜Ÿåˆ—å¤§å°å¯ä½¿ä¸‹è½½é€Ÿåº¦æé«˜ä¸€å€ã€‚è¾ƒæ–°çš„å®¢æˆ·ç«¯ä½¿ç”¨è‡ªé€‚åº”é˜Ÿåˆ—å¤§å°ï¼Œä»¥æ›´å¥½åœ°é€‚åº”ç°ä»£ç½‘ç»œé€Ÿåº¦å’Œæ¡ä»¶ã€‚è¿™ç»å¯¹æ˜¯ä¸€ä¸ªå€¼å¾—è°ƒæ•´çš„å‚æ•°ï¼Œä¹Ÿæ˜¯æœªæ¥æ€§èƒ½ä¼˜åŒ–çš„ä½æ‚¬ç‚¹ã€‚

```go
// MaxBlockSize is the largest number of bytes a request can ask for
const MaxBlockSize = 16384

// MaxBacklog is the number of unfulfilled requests a client can have in its pipeline
const MaxBacklog = 5

func attemptDownloadPiece(c *client.Client, pw *pieceWork) ([]byte, error) {
    state := pieceProgress{
        index:  pw.index,
        client: c,
        buf:    make([]byte, pw.length),
    }

    // Setting a deadline helps get unresponsive peers unstuck.
    // 30 seconds is more than enough time to download a 262 KB piece
    c.Conn.SetDeadline(time.Now().Add(30 * time.Second))
    defer c.Conn.SetDeadline(time.Time{}) // Disable the deadline

    for state.downloaded < pw.length {
        // If unchoked, send requests until we have enough unfulfilled requests
        if !state.client.Choked {
            for state.backlog < MaxBacklog && state.requested < pw.length {
                blockSize := MaxBlockSize
                // Last block might be shorter than the typical block
                if pw.length-state.requested < blockSize {
                    blockSize = pw.length - state.requested
                }

                err := c.SendRequest(pw.index, state.requested, blockSize)
                if err != nil {
                    return nil, err
                }
                state.backlog++
                state.requested += blockSize
            }
        }

        err := state.readMessage()
        if err != nil {
            return nil, err
        }
    }

    return state.buf, nil
}
```

#### main.go

è¿™ä¸ªå¾ˆçŸ­ã€‚æˆ‘ä»¬å¿«åˆ°äº†

```go
package main

import (
    "log"
    "os"

    "github.com/veggiedefender/torrent-client/torrentfile"
)

func main() {
    inPath := os.Args[1]
    outPath := os.Args[2]

    tf, err := torrentfile.Open(inPath)
    if err != nil {
        log.Fatal(err)
    }

    err = tf.DownloadToFile(outPath)
    if err != nil {
        log.Fatal(err)
    }
}
```

## è¿™å¹¶ä¸æ˜¯æ•…äº‹çš„å…¨éƒ¨

ä¸ºäº†ç®€æ´èµ·è§ï¼Œæˆ‘åªåŒ…å«äº†ä¸€äº›é‡è¦çš„ä»£ç ç‰‡æ®µã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œæˆ‘çœç•¥äº†æ‰€æœ‰èƒ¶æ°´ä»£ç ã€è§£æã€å•å…ƒæµ‹è¯•ä»¥åŠæ„å»ºç‰¹æ€§çš„æ— èŠéƒ¨åˆ†ã€‚å¦‚æœä½ æ„Ÿå…´è¶£ï¼Œå¯ä»¥æŸ¥çœ‹æˆ‘çš„[å®Œæ•´å®ç°](https://github.com/veggiedefender/torrent-client)ã€‚