---
date: 2025-01-18
authors:
  - cloaks
categories:
  - Golang 编程实践
tags:
  - Golang
comments: true
---

# **Go 方法接收者的值类型与指针类型详解**

在 Go 语言中，方法接收者（Receiver）决定了方法调用时对象的访问方式。接收者可以是值类型，也可以是指针类型。二者的差异在于是否能直接修改原始对象的值。

本文以一个简单的结构体 `data` 为例，探讨值接收者和指针接收者的行为区别。

<!-- more -->

## **结构体定义**

以下是一个包含三个字段的结构体 `data`：

```go
type data struct {
    num   int
    key   *string
    items map[string]bool
}
```

结构体包含：

1. **`num`**：整型字段。
2. **`key`**：指向字符串的指针。
3. **`items`**：映射类型，用于存储布尔值。

## **方法接收者的两种形式**

在 Go 中，方法可以定义为：

- **值接收者**：方法接收者是值类型，方法中对接收者的修改不会影响原始对象。
- **指针接收者**：方法接收者是指针类型，方法中对接收者的修改会影响原始对象。

以下是 `data` 结构体的两个方法：

=== "指针接收者方法"

    ```go
    func (this *data) pmethod() {
        this.num = 7
    }
    ```

    - **接收者类型**：`*data`。
    - **功能**：直接修改接收者指向的原始对象的 `num` 字段。

=== "值接收者方法"

    ```go
    func (this data) vmethod() {
        this.num = 8
        *this.key = "v.key"
        this.items["vmethod"] = true
    }
    ```

    - **接收者类型**：`data`。
    - **功能**：

        1. 尝试修改接收者的 `num` 字段。
        2. 修改 `key` 指针指向的值。
        3. 修改 `items` 映射中的数据。

## **指针接收者与值接收者的行为分析**

=== "值接收者"

    值接收者方法中，接收者是原始对象的副本。方法对接收者的修改不会影响原始对象。

    以下是值接收者的行为演示：

    ```go
    func (this data) vmethod() {
        this.num = 8              // 修改副本的 num，不影响原始对象。
        *this.key = "v.key"       // 修改 key 指针指向的值，影响原始对象。
        this.items["vmethod"] = true // 修改映射，因为映射是引用类型，影响原始对象。
    }
    ```

    **关键点：**

    1. **基本类型（如 `num`）**：

          - 修改的是接收者的副本，不会影响原始对象。

    2. **指针字段（如 `key`）**：

          - 尽管接收者是值类型，`key` 是一个指针，副本中仍持有原始对象的指针地址。
          - 修改指针指向的值，会影响原始对象。

    3. **引用类型（如 `items`）**：

          - 映射是引用类型，副本与原始对象共享底层数据。
          - 修改映射会影响原始对象。

=== "指针接收者"

    指针接收者方法直接对原始对象的字段进行操作，所有修改都会影响原始对象。

    ```go
    func (this *data) pmethod() {
        this.num = 7 // 修改原始对象的 num 字段
    }
    ```

    **关键点：**

          - 指针接收者直接操作原始对象，因此所有修改都会直接反映到原始对象中。

## **代码演示**

以下代码展示了两种方法的使用：

```go
package main

import "fmt"

func main() {
    key := "original"
    d := data{
        num:   1,
        key:   &key,
        items: make(map[string]bool),
    }

    // 调用值接收者方法
    d.vmethod()
    fmt.Println(d.num)        // 输出: 1 (未修改)
    fmt.Println(*d.key)       // 输出: "v.key" (已修改)
    fmt.Println(d.items)      // 输出: map[vmethod:true] (已修改)

    // 调用指针接收者方法
    d.pmethod()
    fmt.Println(d.num)        // 输出: 7 (已修改)
}
```

## **为什么需要指针接收者**

在以下情况下，建议使用指针接收者：

1. **需要修改原始对象**：如方法中需要更新结构体的字段。
2. **避免副本开销**：对于较大的结构体，使用指针接收者避免每次方法调用都复制结构体。
3. **一致性**：如果结构体的方法中有需要指针接收者的情况，其他方法也可以统一使用指针接收者。

## **总结**

| **特性**             | **值接收者**              | **指针接收者**          |
|----------------------|---------------------------|-------------------------|
| 是否修改原始对象      | 否                        | 是                      |
| 是否存在副本开销      | 是                        | 否                      |
| 修改引用类型字段是否生效 | 是（共享底层数据）          | 是                      |
| 使用场景              | 只读操作；小型结构体方法调用 | 修改原始对象；较大结构体 |

通过合理选择方法接收者的类型，可以更高效、更准确地实现方法的功能，同时避免意外的副作用。